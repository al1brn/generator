#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun May 29 12:31:31 2022

@author: alain

Generate geonodes Blender addon

====================================================================================================
Description

The geonodes implements two layers:
    - Nodes layer
        One class per geometry nodes, for instance AlignEulerToVector wraps the node FunctionNodeAlignEulerToVector
        The Node class initialization creates the geometry nodes
    - Data classes layer
        One class per data type:
            Basis data: Boolean, Integer, Float, Vector, Color, String
            Geometry  : Geometry, Curve, Mesh, Point, Instance, Volume, Curves
            Special   : Collection, Object, Material, Texture, Image
        The methods and properties of the sockets are implemented by creating nodes:
            circle = Mesh.Circle(radius=2.) --> creates the node GeometryNodeMeshCircle
            
A node accepts data sockets as inputs and return data sockets as ouputs
In addition, it can take parameters

====================================================================================================
Use

In a Blender project, create a Geometry nodes modifier and run the following script

from generator.generator import gen_geonodes

gen_geonodes(fpath)

where fpath is the folder into which generating the files


====================================================================================================
geonodes is made of following structure

----------------------------------------------------------------------------------------------------
----- geonodes.core

----- geonodes.core.node

Tree        : Blender NodeTree wrapper
DataSocket  : Root class for socket wrappers
Node        : Root class for blender geometry nodes wrappers

Some specific nodes are implemented in this module
They are used by Tree:
    
NodeGroup   : Root for GroupInput and GroupOutput

GroupInput  : Wrapper for node NodeGroupInput
              property: tree.group_input
              
GroupOutput : Wrapper for node NodeGroupOutput
              property: tree.group_output
              
Viewer      : Wrapper for node GeometryNodeViewer
              One viewer per tree. Data sockets can use the method to_viewer()
              
Frame       : Wrapper for node NodeFrame
              Tree implemenents new_layout() and close_layout() using Frame

SceneTime   : Wrapper for GeometryNodeInputSceneTime        


----- geonodes.core.datasockets

Implements the base class for DataSockets
All the classes are base on geonode.node.DataSocket

For geometry data, only the class Geometry is implemented in this module
The final classes will be created in geonodes.sockets
        
----- geonodes.core.colors

Some colors constants

----- geonodes.core.arrange

arrange function locates the nodes to make the whole tree somehow readable
It works independantly of the geonodes structure and just take the name
of the NodeTree as an argument.

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.nodes

All he nodes generated by the generator

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.sockets

One file per data socket class plus functions.py which contains the global functions

----------------------------------------------------------------------------------------------------
----- geonodes.__init__.py

The pack initi file contains

====================================================================================================

Generation principle

The generation module is designed to ease the updates with the new versions of geometry nodes

Step 1
------
    try to create all the possible nodes by listing all the types in bpy.types:
    
    for type_name in dir(bpy.types):
        try:
            node = nodes.new(type_name)
        except:
            continue
        
        # We have a valid type
        
    The legacy nodes are excluded from the scane
    
Step 2
------
    Each node is analyzed by:
        - Identifying the parameters (non standard attributes)
            Three types of parameters are possible:
                - Non settable parameters, for instance the color selector of an input color node
                - Enum parameters: str param with a list of valid values
                - Non enum settable parameters, the resolution of a circle for instance
            The settable parameters will be part of the node creation argument
        
        - Identifying if the node has "shared sockets"
            Shared sockets are sockets of different types but sharing the same name.
            Only one socket is enabled at a time, depending upon a "driving parameter"
            Example: node FunctionNodeCompare:
                    - Driving parameter : data_type in ('FLOAT', 'INT', 'VECTOR', 'STRING', 'RGBA')
                    - Input sockets     : ['a', 'b']
                    a and b are names shared by sockets of type Float, Integer, Vector, String and Color
                    
        - Renaming sockets homonyms when exist
            For instance node ShaderNodeMath has three input sockets named Value. They are renamed
            value0, value1 and value2
                    
Step 3
------
    file nodes.py generation in folder geonodes.nodes
    
    The __init__ method of the node class is the concatenation of the input sockets and the settable parameters
    
    for instance, the __init__ method of ShaderNodeMath is:
        
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD'):
            
            The node has 3 sockets and one parameter named operation.
            The default value 'ADD' is the one of the parameter at creation time.
            When a socket has the value None, it is left unplugged.
            A socket can be either a value or data socket class. If it is a value, it
            must be an acceptable default value for the input socket.
            
    An additional argument label is used to allow the user to change the node label:
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD', label=None):
            
Step 4
------
    Generation of the data sockets classes.
    
    A data socket basically wraps an output node socket.
    The methods of a data class consist in creating a node and to plug the socket to one
    input socket of this node.
    
    Example:
        Let use x as a Float which is the output socket of a node.
        We can write:
            
            y = x ** 3
            
        This will create the node ShaderNodeMath with the following parameters:
            
            node = Math(value0=self, value1=3, operation='POWER')
            return node.value
        
    Implementation types
    ---------------------
    
    Depending on their behaviors, the nodes can be implented in the following ways:
        
        Constructor
        -----------
            For nodes which don't transform a socket but create new data
            
            Example: GeometryNodeMeshCircle is implemented as a Mesh constructor
            
            @classmethod
            def Circle(cls, vertices=None, radius=None, fill_type='NONE'):
                return cls(nodes.MeshCircle(vertices=vertices, radius=radius, fill_type=fill_type).mesh)
            
        Property
        --------
            For node which return info on data sockets. The properties are kept in local attributes:
                
                self.prop_ = ... node creation
                return self.prop_
            
            Example: GeometryNodeBoundBox returns 3 infos on the geometry : bounding_box, min and max


"""

from datetime import date
import re

import bpy
import mathutils
from pprint import pprint, pformat

from generator import pyparser
from generator import code_gen

from importlib import reload
reload(pyparser)
reload(code_gen)


# ====================================================================================================
# All enums per param

ALL_ENUMS  = {}
DATA_TYPE_TUPLES = []

def add_enum_list(key, values):
    ALL_ENUMS[key] = ALL_ENUMS.get(key, set()).union(values)
    if key == 'data_type':
        DATA_TYPE_TUPLES.append(values)

    
def print_all_enums():
    
    print()
    print("list of enums:")
    for k, v in ALL_ENUMS.items():
        print(f"{k:15s}: {v}")
        
    print()
    print('-'*30)
    print("data_type tuples:")
    print()
    for v in DATA_TYPE_TUPLES:
        print(v)
    

# ====================================================================================================


DEPRECATED = {
    "GeometryNodeAttributeTransfer",
    "ShaderNodeCombineRGB",
    "ShaderNodeMixRGB",
    "ShaderNodeSeparateRGB",
    }

NODES_MENU = {
    
    # DEPRECATED

    #"transfer_attribute"         : ("attribute"                 , "attribute/transfer_attribute"          ),
    #"combine_rgb"                : ("color"                     , "color/combine_rgb"                     ),
    #"mix"                        : ("color"                     , "color/mix_rgb"                         ),
    
    # CURRENT 
    
    
    "index"                      : ("attribute"                 , "attribute/index"                       ),
    "attribute_statistic"        : ("attribute"                 , "attribute/attribute_statistic"         ),
    "capture_attribute"          : ("attribute"                 , "attribute/capture_attribute"           ),
    "domain_size"                : ("attribute"                 , "attribute/domain_size"                 ),
    "store_named_attribute"      : ("attribute"                 , "attribute/store_named_attribute"       ),
    "remove_named_attribute"     : ("attribute"                 , "attribute/remove_named_attribute"      ),
    
    "color_ramp"                 : ("color"                     , "color/color_ramp"                      ),
    "colorramp"                  : ("color"                     , "color/color_ramp"                      ),
    "combine_color"              : ("color"                     , "color/combine_color"                   ), # 3.3
    "mix"                        : ("color"                     , "color/mix"                             ),
    "rgb_curves"                 : ("color"                     , "color/rgb_curves"                      ),
    "separate_color"             : ("color"                     , "color/separate_color"                  ), # 3.3

    "curve_length"               : ("curve"                     , "curve/curve_length"                    ),
    "curve_to_mesh"              : ("curve"                     , "curve/curve_to_mesh"                   ),
    "curve_to_points"            : ("curve"                     , "curve/curve_to_points"                 ),
    "deform_curves_on_surface"   : ("curve"                     , "curve/deform_curves_on_surface"        ), # 3.3
    "fill_curve"                 : ("curve"                     , "curve/fill_curve"                      ),
    "fillet_curve"               : ("curve"                     , "curve/fillet_curve"                    ),
    "resample_curve"             : ("curve"                     , "curve/resample_curve"                  ),
    "reverse_curve"              : ("curve"                     , "curve/reverse_curve"                   ),
    "sample_curve"               : ("curve"                     , "curve/sample_curve"                    ),
    "subdivide_curve"            : ("curve"                     , "curve/subdivide_curve"                 ),
    "trim_curve"                 : ("curve"                     , "curve/trim_curve"                      ),
    
    "curve_handle_position"      : ("curve"                     , "curve/curve_handle_position"           ),
    "curve_handle_positions"     : ("curve"                     , "curve/curve_handle_position"           ),

    "curve_tangent"              : ("curve"                     , "curve/curve_tangent"                   ),
    "curve_tilt"                 : ("curve"                     , "curve/curve_tilt"                      ),
    "endpoint_selection"         : ("curve"                     , "curve/endpoint_selection"              ),
    "handle_type_selection"      : ("curve"                     , "curve/handle_type_selection"           ),
    "is_spline_cyclic"           : ("curve"                     , "curve/is_spline_cyclic"                ),
    "spline_length"              : ("curve"                     , "curve/spline_length"                   ),
    "spline_parameter"           : ("curve"                     , "curve/spline_parameter"                ),
    "spline_resolution"          : ("curve"                     , "curve/spline_resolution"               ),
    "set_curve_normal"           : ("curve"                     , "curve/set_curve_normal"                ), # 3.4
    "set_curve_radius"           : ("curve"                     , "curve/set_curve_radius"                ),
    "set_curve_tilt"             : ("curve"                     , "curve/set_curve_tilt"                  ),
    "set_handle_positions"       : ("curve"                     , "curve/set_handle_positions"            ),
    "set_handle_type"            : ("curve"                     , "curve/set_handle_type"                 ),
    "set_spline_cyclic"          : ("curve"                     , "curve/set_spline_cyclic"               ),
    "set_spline_resolution"      : ("curve"                     , "curve/set_spline_resolution"           ),
    "set_spline_type"            : ("curve"                     , "curve/set_spline_type"                 ),

    
    "index"                      : ("curve_primitives"          , "curve_primitives/index"                ),
    "arc"                        : ("curve_primitives"          , "curve_primitives/arc"                  ),
    "bezier_segment"             : ("curve_primitives"          , "curve_primitives/bezier_segment"       ),
    "curve_circle"               : ("curve_primitives"          , "curve_primitives/curve_circle"         ),
    "curve_line"                 : ("curve_primitives"          , "curve_primitives/curve_line"           ),
    
    "curve_spiral"               : ("curve_primitives"          , "curve_primitives/curve_spiral"         ),
    "spiral"                     : ("curve_primitives"          , "curve_primitives/curve_spiral"         ),
    
    "quadratic_bezier"           : ("curve_primitives"          , "curve_primitives/quadratic_bezier"     ),
    "quadrilateral"              : ("curve_primitives"          , "curve_primitives/quadrilateral"        ),
    "star"                       : ("curve_primitives"          , "curve_primitives/star"                 ),
    
    "offset_point_in_curve"      : ("curve_topology"            , "curve_topology/offset_point_in_curve"  ), # 3.4
    "curve_of_point"             : ("curve_topology"            , "curve_topology/curve_of_point"         ), # 3.4
    "points_of_curve"            : ("curve_topology"            , "curve_topology/points_of_curve"        ), # 3.4

    "bounding_box"               : ("geometry"                  , "geometry/bounding_box"                 ),
    "convex_hull"                : ("geometry"                  , "geometry/convex_hull"                  ),
    "delete_geometry"            : ("geometry"                  , "geometry/delete_geometry"              ),
    "duplicate_elements"         : ("geometry"                  , "geometry/duplicate_elements"           ),
    "geometry_proximity"         : ("geometry"                  , "geometry/geometry_proximity"           ),
    "geometry_to_instance"       : ("geometry"                  , "geometry/geometry_to_instance"         ),
    "join_geometry"              : ("geometry"                  , "geometry/join_geometry"                ),
    "merge_by_distance"          : ("geometry"                  , "geometry/merge_by_distance"            ),
    "raycast"                    : ("geometry"                  , "geometry/raycast"                      ),
    "sample_index"               : ("geometry"                  , "geometry/sample_index"                 ),
    "sample_nearest"             : ("geometry"                  , "geometry/sample_nearest"               ),
    "separate_components"        : ("geometry"                  , "geometry/separate_components"          ),
    "separate_geometry"          : ("geometry"                  , "geometry/separate_geometry"            ),
    "transform"                  : ("geometry"                  , "geometry/transform"                    ),
    "set_id"                     : ("geometry"                  , "geometry/set_id"                       ),
    "set_position"               : ("geometry"                  , "geometry/set_position"                 ),

    "boolean"                    : ("input"                     , "input/boolean"                         ),
    "collection_info"            : ("input"                     , "input/collection_info"                 ),
    "color"                      : ("input"                     , "input/color"                           ),
    "integer"                    : ("input"                     , "input/integer"                         ),
    "is_viewport"                : ("input"                     , "input/is_viewport"                     ),
    "material"                   : ("input"                     , "input/material"                        ),
    "object_info"                : ("input"                     , "input/object_info"                     ),
    "self_object"                : ("input"                     , "input/self_object"                     ), # 3.4
    "scene_time"                 : ("input"                     , "input/scene_time"                      ),
    "string"                     : ("input"                     , "input/string"                          ),
    "value"                      : ("input"                     , "input/value"                           ),
    "vector"                     : ("input"                     , "input/vector"                          ),

    "input_index"                : ("input"                     , "input/input_index"                     ),
    "index"                      : ("input"                     , "input/input_index"                     ),
    "named_attribute"            : ("input"                     , "input/named_attribute"                 ),
    "normal"                     : ("input"                     , "input/normal"                          ),
    "position"                   : ("input"                     , "input/position"                        ),
    "radius"                     : ("input"                     , "input/radius"                          ),
    "id"                         : ("input"                     , "input/id"                              ),

    "instance_on_points"         : ("instances"                 , "instances/instance_on_points"          ),
    "instances_to_points"        : ("instances"                 , "instances/instances_to_points"         ),
    "rotate_instances"           : ("instances"                 , "instances/rotate_instances"            ),
    "scale_instances"            : ("instances"                 , "instances/scale_instances"             ),
    "translate_instances"        : ("instances"                 , "instances/translate_instances"         ),
    "realize_instances"          : ("instances"                 , "instances/realize_instances"           ),
    
    "instance_scale"             : ("instances"                 , "instances/instance_scale"              ), # 3.3
    "instance_rotation"          : ("instances"                 , "instances/instance_rotation"           ), # 3.3
    
    "replace_material"           : ("material"                  , "material/replace_material"             ),
    "material_index"             : ("material"                  , "material/material_index"               ),
    "material_selection"         : ("material"                  , "material/material_selection"           ),
    "set_material"               : ("material"                  , "material/set_material"                 ),
    "set_material_index"         : ("material"                  , "material/set_material_index"           ),

    "dual_mesh"                  : ("mesh"                      , "mesh/dual_mesh"                        ),
    "edge_paths_to_curves"       : ("mesh"                      , "mesh/edge_paths_to_curves"             ), # 3.3
    "edge_paths_to_selection"    : ("mesh"                      , "mesh/edge_paths_to_selection"          ), # 3.3
    "extrude_mesh"               : ("mesh"                      , "mesh/extrude_mesh"                     ),
    "flip_faces"                 : ("mesh"                      , "mesh/flip_faces"                       ),
    "mesh_boolean"               : ("mesh"                      , "mesh/mesh_boolean"                     ),
    "mesh_to_curve"              : ("mesh"                      , "mesh/mesh_to_curve"                    ),
    "mesh_to_points"             : ("mesh"                      , "mesh/mesh_to_points"                   ),
    "mesh_to_volume"             : ("mesh"                      , "mesh/mesh_to_volume"                   ), # 3.3
    "sample_nearest_surface"     : ("mesh"                      , "mesh/sample_nearest_surface"           ), # 3.4
    "sample_uv_surface"          : ("mesh"                      , "mesh/sample_uv_surface"                ), # 3.4
    "scale_elements"             : ("mesh"                      , "mesh/scale_elements"                   ),
    "split_edges"                : ("mesh"                      , "mesh/split_edges"                      ),
    "subdivide_mesh"             : ("mesh"                      , "mesh/subdivide_mesh"                   ),
    "subdivision_surface"        : ("mesh"                      , "mesh/subdivision_surface"              ),
    "triangulate"                : ("mesh"                      , "mesh/triangulate"                      ),
    "edge_angle"                 : ("mesh"                      , "mesh/edge_angle"                       ),
    "edge_neighbors"             : ("mesh"                      , "mesh/edge_neighbors"                   ),
    "edge_vertices"              : ("mesh"                      , "mesh/edge_vertices"                    ),
    "face_area"                  : ("mesh"                      , "mesh/face_area"                        ),
    "face_is_planar"             : ("mesh"                      , "mesh/face_is_planar"                   ),
    "face_neighbors"             : ("mesh"                      , "mesh/face_neighbors"                   ),
    "face_set_boundaries"        : ("mesh"                      , "mesh/face_set_boundaries"              ), # 3.4
    "is_shade_smooth"            : ("mesh"                      , "mesh/is_shade_smooth"                  ),
    "mesh_island"                : ("mesh"                      , "mesh/mesh_island"                      ),
    "shortest_edge_paths"        : ("mesh"                      , "mesh/shortest_edge_paths"              ), # 3.3
    "vertex_neighbors"           : ("mesh"                      , "mesh/vertex_neighbors"                 ),
    "set_shade_smooth"           : ("mesh"                      , "mesh/set_shade_smooth"                 ),

    "cone"                       : ("mesh_primitives"           , "mesh_primitives/cone"                  ),
    "cube"                       : ("mesh_primitives"           , "mesh_primitives/cube"                  ),
    "cylinder"                   : ("mesh_primitives"           , "mesh_primitives/cylinder"              ),
    "grid"                       : ("mesh_primitives"           , "mesh_primitives/grid"                  ),
    
    "icosphere"                  : ("mesh_primitives"           , "mesh_primitives/icosphere"             ),
    "ico_sphere"                 : ("mesh_primitives"           , "mesh_primitives/icosphere"             ),

    "mesh_circle"                : ("mesh_primitives"           , "mesh_primitives/mesh_circle"           ),
    "mesh_line"                  : ("mesh_primitives"           , "mesh_primitives/mesh_line"             ),
    "uv_sphere"                  : ("mesh_primitives"           , "mesh_primitives/uv_sphere"             ),
    
    "corners_of_face"            : ("mesh_topology"             , "mesh_topology/corners_of_face"         ), # 3.4
    "corners_of_vertex"          : ("mesh_topology"             , "mesh_topology/corners_of_vertex"       ), # 3.4
    "edges_of_corner"            : ("mesh_topology"             , "mesh_topology/edges_of_corner"         ), # 3.4
    "edges_of_vertex"            : ("mesh_topology"             , "mesh_topology/edges_of_vertex"         ), # 3.4
    "face_of_corner"             : ("mesh_topology"             , "mesh_topology/face_of_corner"          ), # 3.4
    "offset_corner_in_face"      : ("mesh_topology"             , "mesh_topology/offset_corner_in_face"   ), # 3.4
    "vertex_of_corner"           : ("mesh_topology"             , "mesh_topology/vertex_of_corner"        ), # 3.4

    "viewer"                     : ("output"                    , "output/viewer"                         ),

    "distribute_points_in_volume" : ("point"                    , "point/distribute_points_in_volume"     ), # 3.4
    "distribute_points_on_faces" : ("point"                     , "point/distribute_points_on_faces"      ),
    "points_to_vertices"         : ("point"                     , "point/points_to_vertices"              ),
    "points_to_volume"           : ("point"                     , "point/points_to_volume"                ),
    "set_point_radius"           : ("point"                     , "point/set_point_radius"                ),

    "points"                     : ("point"                     , "point/points"                          ), # 3.3

    "join_strings"               : ("text"                      , "text/join_strings"                     ),
    "replace_string"             : ("text"                      , "text/replace_string"                   ),
    "slice_string"               : ("text"                      , "text/slice_string"                     ),
    "special_characters"         : ("text"                      , "text/special_characters"               ),
    "string_length"              : ("text"                      , "text/string_length"                    ),
    "string_to_curves"           : ("text"                      , "text/string_to_curves"                 ),
    "value_to_string"            : ("text"                      , "text/value_to_string"                  ),

    "brick_texture"              : ("texture"                   , "texture/brick"                         ),
    "checker_texture"            : ("texture"                   , "texture/checker"                       ),
    "gradient_texture"           : ("texture"                   , "texture/gradient"                      ),
    "image_texture"              : ("texture"                   , "texture/image"                         ),
    "magic_texture"              : ("texture"                   , "texture/magic"                         ),
    "musgrave_texture"           : ("texture"                   , "texture/musgrave"                      ),
    "noise_texture"              : ("texture"                   , "texture/noise"                         ),
    "voronoi_texture"            : ("texture"                   , "texture/voronoi"                       ),
    "wave_texture"               : ("texture"                   , "texture/wave"                          ),
    "white_noise_texture"        : ("texture"                   , "texture/white_noise"                   ),

    "accumulate_field"           : ("utilities"                 , "utilities/accumulate_field"            ),
    "align_euler_to_vector"      : ("utilities"                 , "utilities/align_euler_to_vector"       ),
    "boolean_math"               : ("utilities"                 , "utilities/boolean_math"                ),
    "clamp"                      : ("utilities"                 , "utilities/clamp"                       ),
    "compare"                    : ("utilities"                 , "utilities/compare"                     ),
    "field_at_index"             : ("utilities"                 , "utilities/field_at_index"              ),
    "float_curve"                : ("utilities"                 , "utilities/float_curve"                 ),
    "float_to_integer"           : ("utilities"                 , "utilities/float_to_integer"            ),
    "map_range"                  : ("utilities"                 , "utilities/map_range"                   ),
    "math"                       : ("utilities"                 , "utilities/math"                        ),
    "random_value"               : ("utilities"                 , "utilities/random_value"                ),
    "rotate_euler"               : ("utilities"                 , "utilities/rotate_euler"                ),
    "switch"                     : ("utilities"                 , "utilities/switch"                      ),
    "interpolate_domain"         : ("utilities"                 , "utilities/interpolate_domain"          ), # 3.3

    "pack_uv_islands"            : ("uv"                        , "uv/pack_uv_islands"                    ), # 3.3
    "uv_unwrap"                  : ("uv"                        , "uv/uv_unwrap"                          ), # 3.3
    
    "combine_xyz"                : ("vector"                    , "vector/combine_xyz"                    ),
    "separate_xyz"               : ("vector"                    , "vector/separate_xyz"                   ),
    "vector_curves"              : ("vector"                    , "vector/vector_curves"                  ),
    "vector_math"                : ("vector"                    , "vector/vector_math"                    ),
    "vector_rotate"              : ("vector"                    , "vector/vector_rotate"                  ),

    "volume_to_mesh"             : ("volume"                    , "volume/volume_to_mesh"                 ),
    "volume_cube"                : ("volume"                    , "volume/volume_cube"                    ), # 3.3
    
    "group"                      : ("group"                     , "group"                                 ),
}

# ====================================================================================================
# Output sockets data types

OUTPUT_SOCKETS_CLASS = {
    'GeometryNodeBoundBox'                     : {'bounding_box'    : 'Mesh',},
    'GeometryNodeConvexHull'                   : {'convex_hull'     : 'Mesh',},
    'GeometryNodeDeformCurvesOnSurface'        : {'curves'          : 'Curve',},
    'GeometryNodeDualMesh'                     : {'dual_mesh'       : 'Mesh',},
    'GeometryNodeEdgePathsToCurves'            : {'curves'          : 'Curve',},
    'GeometryNodeInterpolateCurves'            : {'curves'          : 'Curve',},
    'GeometryNodePoints'                       : {'geometry'        : 'Points',},
    'GeometryNodeReplaceMaterial'              : {'geometry'        : 'Mesh',},
    'GeometryNodeScaleElements'                : {'geometry'        : 'Mesh',},
    'GeometryNodeSeparateComponents'           : {'point_cloud'     : 'Points',},
    #'GeometryNodeSetMaterial'                  : {'geometry'        : 'Mesh',},
    #'GeometryNodeSetMaterialIndex'             : {'geometry'        : 'Mesh',},
    'GeometryNodeSetShadeSmooth'               : {'geometry'        : 'Mesh',},
    'GeometryNodeSetSplineCyclic'              : {'geometry'        : 'Curve',},
    'GeometryNodeSetSplineResolution'          : {'geometry'        : 'Curve',},
    'GeometryNodeStringToCurves'               : {'curve_instances' : 'Instances',},
}

# ====================================================================================================
# Some nodes need to reorder the input sockets for more natural use
# Example : the input sockets node ShaderNodeMixRGB are order fac, color1, color2
#           by reordering color1, color2, fac allows to call color.mix(color_argument)
#           rather than color.mix(color2=color_argument)

INPUT_SOCKETS_ORDER = {
    'ShaderNodeMixRGB' : {'Fac': 2, 'Color1': 0, 'Color2': 1},
}

# ====================================================================================================
# Utility

def indent_set(depth=0):
    _indent_ = "    "
    _0_ = "\n" + _indent_ * max(0, 0 + depth)
    _1_ = "\n" + _indent_ * max(0, 1 + depth)
    _2_ = "\n" + _indent_ * max(0, 2 + depth)
    _3_ = "\n" + _indent_ * max(0, 3 + depth)
    _4_ = "\n" + _indent_ * max(0, 4 + depth)
    
    return _indent_, _0_, _1_, _2_, _3_, _4_

_indent_, _0_, _1_, _2_, _3_, _4_ = indent_set(0)


# ====================================================================================================
# Socket name replaced by label

def socket_name(blender_socket):
    return blender_socket.name #if blender_socket.label == "" else blender_socket.label


# ====================================================================================================
# Call argument
#
# Argument types:
#
# - SOCKET: The name of an input socket (wsocket must be not None).
#           If the socket is multi input, it must be the first argument:
#               - header: *name
#               - call  : *name
#           If the socket is not multi input
#               - header: name=None
#               - call  : name=name
#
# - PARAM : it is the name of a param (param can be None). It can be fixed or not
#           If fixed:
#               - header: ""
#               - call  : name=name
#           If not fixed
#               - header: name='VALUE'
#               - call  : name=name
#
# - CLS   : it is the cls argument
#         : - header : cls
#         : - call   : ""
#
# - OTHER : Not a socket nor a param
#         : - header : ""
#         : - call   : ""


class Argument:
    def __init__(self, arg_type, name, is_self=False, label=None):
        self.arg_type = arg_type
        self.name     = name
        self.label    = label
        self.is_self  = is_self
        self.ignore   = False

    @classmethod
    def Socket(cls, name, wsocket, is_self=False, label=None):
        arg         = cls('SOCKET', name, is_self=is_self, label=label)
        arg.wsocket = wsocket
        arg.is_self = is_self
        return arg
        
    @classmethod
    def Param(cls, name, value, quote_str_value=True, param=None, is_fixed=False):
        arg = cls('PARAM', name)
        if isinstance(value, str) and quote_str_value:
            arg.value = f"'{value}'"
        else:
            arg.value = value

        arg.param    = param
        arg.is_fixed = is_fixed
        
        # Specific params
        
        if isinstance(arg.value, (bpy.types.bpy_func, bpy.types.bpy_prop_collection)):
            arg.ignore = True
        
        return arg
        
    @classmethod
    def Cls(cls):
        return cls('CLS', "cls")
    
    @classmethod
    def Other(cls, header_str="", call_str="", **kwargs):
        arg = cls('OTHER', None)
        arg.header_str = header_str
        arg.call_str   = call_str
        for k, v in kwargs:
            setattr(arg, k, v)
        return arg
    
    @property
    def name_or_label(self):
        return self.name if self.label is None else self.label
        
    @property
    def is_socket(self):
        return self.arg_type == 'SOCKET'
    
    @property
    def is_multi(self):
        if self.is_socket and not self.is_shared:
            return self.wsocket.is_multi_input
        else:
            return False
    
    @property
    def is_param(self):
        return self.arg_type == 'PARAM'

    @property
    def is_cls(self):
        return self.arg_type == 'CLS'
    
    @property
    def is_shared(self):
        return isinstance(self.wsocket, list)
    
    @property
    def sheader(self):
        
        if self.ignore:
            return ""
        
        if self.arg_type == 'CLS':
            return "cls"
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name_or_label}"
                else:
                    return f"*{self.name_or_label}"
            else:
                if self.is_self:
                    return "self"
                else:
                    return f"{self.name_or_label}=None"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return ""
            else:
                return f"{self.name}={self.value}"
            
        elif self.arg_type == 'OTHER':
            return self.header_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

    @property
    def scall(self):
        
        if self.ignore:
            return ""

        if self.arg_type == 'CLS':
            return ""
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name}"
                else:
                    return f"*{self.name}"
            else:
                if self.is_self:
                    return f"{self.name}=self"
                else:
                    return f"{self.name}={self.name_or_label}"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return f"{self.name}={self.value}"
            else:
                return f"{self.name}={self.name}"
            
        elif self.arg_type == 'OTHER':
            return self.call_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

        
    def scomment(self, **kwargs):
        
        if self.ignore:
            return ""
        
        _, arg_rename = Arguments.extract_arg_rename(**kwargs)
        
        if self.arg_type == 'CLS':
            return ""
        
        if self.is_self:
            return ""
        
        if self.arg_type == 'OTHER':
            if self.header_str == "":
                return ""
            else:
                s = self.header_str
                if s == "node_color = None":
                    return "node_color (color): Node background color"
                elif s == "node_label = None":
                    return "node_label (str): Node label"
                else:
                    return self.header_str.replace('=', ':')
            
        s = f"{self.name}"
        if s in arg_rename:
            s = arg_rename[s]
            
        if self.is_socket:
            s += ": "
            if self.is_multi:
                s += "<m>"
            if isinstance(self.wsocket, list):
                s += str([ws.class_name for ws in self.wsocket])
            else:
                s += self.wsocket.class_name

        else:
            if self.param is None:
                return ""
                #s += f"({type(self.value).__name__}): {self.value}"
            else:
                if self.is_fixed:
                    return ""
                
                s += f" ({type(self.value).__name__}): {self.value}"
                if self.param.is_enum:
                    s += f" in {self.param.short_values}"

        return s
    
    @property
    def splug(self):
        
        if self.ignore:
            return None
        
        if not self.is_socket or self.is_shared:
            return None
        
        s = f"self.plug({self.wsocket.index}, "
        if self.is_self:
            s += "self"
            if self.is_multi:
                s += f" *{self.wsocket.uname}"
            return s + ")"
        else:
            if self.is_multi:
                s += "*"
            return s + f"{self.wsocket.uname})"
        
# ---------------------------------------------------------------------------
# A list of Arguments

class Arguments(list):
    
    def add(self, arg):
        if arg.is_self or arg.is_cls:
            self.insert(0, arg)
            
        elif arg.is_multi:
            if len(self) == 0:
                self.append(arg)
            elif self[0].is_self:
                self.insert(1, arg)
            else:
                self.insert(0, arg)
                
        else:
            self.append(arg)
        
    @property
    def sheader(self):
        s = ""
        for arg in self:
            sh = arg.sheader
            if sh != "":
                s += f", {sh}"
        if s != "":
            return s[2:]
        else:
            return s
        
    @property
    def scall(self):
        s = ""
        for arg in self:
            if arg.is_cls:
                continue
            
            if arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"
            
        for arg in self:
            if not arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"

        if s != "":
            return s[2:]
        else:
            return s

    # ---------------------------------------------------------------------------
    # Check the order of the sockets arguments
    
    def check_order(self, bl_idname):

        order = INPUT_SOCKETS_ORDER.get(bl_idname)
        if order is None:
            return
        
        reorder = [None] * len(order)
        for arg in self:
            if not arg.is_socket:
                continue
            
            name = socket_name(arg.wsocket.bsocket)
            if name in order:
                reorder[order[name]] = arg
        
        for arg in reorder:
            if arg is not None:
                self.remove(arg)
            
        for arg in reversed(reorder):
            if arg is not None:
                self.insert(0, arg)

    # ---------------------------------------------------------------------------
    # Generate the comments in a node call
    
    def documentation(self):
        
        text = ""
        _1_ = "\n        "
        _2_ = _1_ + "    "
        
        sockets = False
        for arg in self:
            
            if arg.is_self:
                continue
            
            if arg.is_param and arg.is_fixed:
                continue
                
            else:
                s = arg.scomment()
                if s == "":
                    continue
                
                if not sockets:
                    text += _1_ + "Args:"
                    sockets = True
                    
                text += _2_ + s
                    
        return text
    
    # ---------------------------------------------------------------------------
    # Fixed parameters
    
    def fixed_parameters(self):
        
        text = ""
        _1_ = "\n        "
        
        for arg in self:
            if arg.is_param and arg.is_fixed:
                text += _1_ + f"- {arg.name} = {arg.value}"
                
        return text
    
    # ====================================================================================================    
    # DataClass and Domain methods implementing Nodes
    #
    # - method_header       : returns the header of the DataClass method
    # - node_init_arguments : returns the arguments for node creation (plus the use of self)
    #
    # The basic idea is the following
    #
    # DataSocket or Domain level
    # --------------------------
    # def method(self, **kwargs):
    #
    # Node level
    # ----------
    # node = Node(key = key for key in kwargs)
    #
    # In actual implementation, some changes are possible
    #
    # 1) 'self' can be a value of a node argument
    #    def set_position(self, ...) --> node = SetPosition(geometry=self, ...)
    #
    #    Some arguments are not in the DataSocket method but are computed by the DataSocket instance
    #    This for instance the case for Domain methods which keep a selection value:
    #    def set_shade_smooth(...) --> node = SetPosition(..., selection=self.selection, ...)
    #
    #    RULE 1
    #    ------
    #
    #    Arguments in fixed_args dictionary:
    #    - don't appear in the method header
    #    - are implemented key=value in the node call
    #
    # 2) Some arguments can be renamed when exposed in the domain method:
    #    def add(self, value=None) --> node = Math(operation='ADD', value0=self, value1=value)
    #
    #    RULE 2
    #    ------
    #
    #    An optional rename dictionary is provided with: node_name: method_name entries
    #
    # 3) Some operations can be required on argument before being passed to the node creation
    #    def sample_index(..., index=None, ...) --> node = SampleIndex(..., index=self.index_for_sample(index), ...)
    #
    #    The function call can't be passed in the fixed_args dictionary because the argument wouln't appear
    #    in the method call. We need another rule:
    #
    #    RULE 3
    #    ------
    #
    #    Keys named {arg_name}_VALUE give the value to use when calling the node rather than the arg_name.
    #
    #    For the example above, the fixed_args must contain the entry:
    #    'index_VALUE': 'self.index_for_sample(index)
    
    # ----------------------------------------------------------------------------------------------------
    # RULE 2 - Extract the arg_rename dictionary
    
    @staticmethod
    def extract_arg_rename(**kwargs):

        fixed_args = {**kwargs}
        if 'arg_rename' in fixed_args:
            arg_rename = {**fixed_args['arg_rename']}
            del fixed_args['arg_rename']
            
        else:
            arg_rename = {}

        if 'use_clamp' not in arg_rename:
            arg_rename['use_clamp'] = 'clamp'
            
        return fixed_args, arg_rename
    
    # ----------------------------------------------------------------------------------------------------
    # Method header
    
    def method_header(self, **kwargs):
        
        vals = []
        
        # ----- RULE 2 - extract the arg_rename dict
        
        fixed_args, arg_rename = self.extract_arg_rename(**kwargs)
            
        # ---------------------------------------------------------------------------
        # We make two passes:
        # - first for multi argument
        # - second for non multi argument
        
        for multi_pass in [True, False]:
            for arg in self:
                
                # ----- Argument name
                
                arg_name = arg.name_or_label
                if arg_name in arg_rename:
                    arg_name = arg_rename[arg_name]
                    
                # ----- The argument is fixed: we don't it as  method argument
                
                if arg_name in fixed_args.keys():
                    continue
                
                # ----- We write it

                if arg.arg_type == 'SOCKET' and arg.is_multi:
                    if multi_pass:
                        vals.append(f"*{arg_name}")
                        
                else:
                    if not multi_pass:
                        if arg.arg_type == 'SOCKET':
                            vals.append(f"{arg_name}=None")
                        else:
                            vals.append(f"{arg_name}={arg.value}")
                
        return vals
    
    # ----------------------------------------------------------------------------------------------------
    # Node calls
    
    def node_init_arguments(self, **kwargs):
        
        vals = []
        
        # ----- RULE 2 - extract the arg_rename dict
        
        fixed_args, arg_rename = self.extract_arg_rename(**kwargs)
        
        # ---- RULE 3: Get the {arg}_VALUE entries and add a fixed entry
        
        new_fixed_args = {}
        for key in fixed_args:
            if len(key) <= 6:
                continue
            if key[-6:] == '_VALUE':
                new_fixed_args[key[:-6]] = fixed_args[key]
                
        fixed_args = {**fixed_args, **new_fixed_args}
        
        # ---------------------------------------------------------------------------
        # We make two passes:
        # - first for multi argument
        # - second for non multi argument
        
        for multi_pass in [True, False]:
            for arg in self:
                
                # ----- Argument name
                
                arg_name = arg.name_or_label
                if arg_name in arg_rename:
                    arg_name = arg_rename[arg_name]

                # ----- We write it

                if arg.arg_type == 'SOCKET' and arg.is_multi:
                    if multi_pass:
                        if arg.name_or_label in fixed_args.keys():
                            vals.append(f"{arg.name_or_label}={forced[arg_name]}")
                        else:
                            vals.append(f"*{arg_name}")
                            
                else:
                    if not multi_pass:
                        if arg_name in fixed_args.keys():
                            vals.append(f"{arg.name_or_label}={fixed_args[arg_name]}")
                        else:
                            vals.append(f"{arg.name_or_label}={arg_name}")
                
        return ", ".join(vals)


# ====================================================================================================
# Socket wrapper

class WSocket:
    
    SOCKET_CLASSES = {
        'NodeSocketBool'        : ('Boolean',    '',             'BOOLEAN'), 

        'NodeSocketInt'         : ('Integer',    '',             'INT'), 
        'NodeSocketIntUnsigned' : ('Integer',    'Unsigned',     'INT'), 

        'NodeSocketFloat'       : ('Float',      '',             'FLOAT'), 
        'NodeSocketFloatFactor' : ('Float',      'Factor',       'FLOAT'),
        'NodeSocketFloatAngle'  : ('Float',      'Angle',        'FLOAT'), 
        'NodeSocketFloatDistance': ('Float',     'Distance',     'FLOAT'), 

        'NodeSocketVector'      : ('Vector',     '',             'FLOAT_VECTOR'), 
        'NodeSocketVectorEuler' : ('Vector',     'Rotation',     'FLOAT_VECTOR'),
        'NodeSocketVectorXYZ'   : ('Vector',     'xyz',          'FLOAT_VECTOR'), 
        'NodeSocketVectorTranslation' : ('Vector', 'Translation','FLOAT_VECTOR'), 

        'NodeSocketColor'       : ('Color',      '',             'FLOAT_COLOR'), 
        'NodeSocketString'      : ('String',     '',             'FLOAT_COLOR'), 

        'NodeSocketGeometry'    : ('Geometry',   '',              None), 

        'NodeSocketCollection'  : ('Collection', '',              None), 
        'NodeSocketImage'       : ('Image',      '',              None), 
        'NodeSocketMaterial'    : ('Material',   '',              None), 
        'NodeSocketObject'      : ('Object',     '',              None), 
        'NodeSocketTexture'     : ('Texture',    '',              None), 
        'NodeSocketVirtual'     : ('Virtual',    '',              None),
        }
        
    DATA_TYPES = {
        'INT'         : 'Integer',
        'RGBA'        : 'Color',
        'FLOAT_VECTOR': 'Vector',
        'FLOAT_COLOR' : 'Color',
    }
    
    DOMAIN_DATA_TYPES = {
        'Float'     : 'FLOAT',
        'Integer'   : 'INT',
        'Vector'    : 'FLOAT_VECTOR',
        'Color'     : 'FLOAT_COLOR',
        'Boolean'   : 'BOOLEAN'
    }

    def __init__(self, bsocket, index):
        self.bsocket    = bsocket
        self.index      = index
        self.uname      = self.name
        self.class_name = WSocket.SOCKET_CLASSES[self.bsocket.bl_idname][0]
        self.domain_data_type = WSocket.DOMAIN_DATA_TYPES.get(self.class_name)
        if self.class_name == 'Geometry':
            if self.name.lower() in ['mesh', 'points', 'instances', 'volume', 'curve']:
                self.class_name = self.name.capitalize()
            elif self.name.lower() == 'curves':
                self.class_name = 'Curve'
                
                
    def __repr__(self):
        return f"<{self.uname} ({self.class_name})>"
    
    @staticmethod
    def domain_data_type(bl_idname):
        return WSocket.SOCKET_CLASSES[bl_idname][2]
    
    @property
    def bl_idname(self):
        return self.bsocket.bl_idname
        
    @property
    def enabled(self):
        return self.bsocket.enabled
    
    @property
    def name(self):
        s = socket_name(self.bsocket).lower().replace(' ', '_').replace('-', '_')
        if s == 'id':
            return 'ID'
        else:
            return s
    
    @property
    def is_multi_input(self):
        return self.bsocket.is_multi_input
    
    @property
    def is_output(self):
        return self.bsocket.is_output
    
# ---------------------------------------------------------------------------
# A list of WSockets

class WSockets(list):
    
    def __init__(self, bsockets):
        super().__init__()
        self.bsockets = bsockets
        for index, bsocket in enumerate(self.bsockets):
            if bsocket.bl_idname != 'NodeSocketVirtual':
                self.append(WSocket(bsocket, index))
            
        # ---------------------------------------------------------------------------
        # Sockets can have the same name. Two cases:
        # 1. HOMNYMS: They are of the same class
        #    Only for input sockets. It correspond to parameters of same types,
        #    for instance for an operation
        # 2. SHARED: They are not of the same class
        #    Only one of them can be enabled
        
        names = {}
        for wsock in self:
            if wsock.name in names:
                names[wsock.name].append(wsock)
            else:
                names[wsock.name] = [wsock]
                
        # ----- unames
        # - key   : the unique name shared between several sockets
        # - value : the list of wsockets it is shared among
                
        self.unames = {}
        for name, wsocks in names.items():
            if len(wsocks) == 1:
                self.unames[name] = wsocks[0]
            else:
                class_name    = wsocks[0].class_name
                display_shape = wsocks[0].bsocket.display_shape
                distinction   = 'HOMONYMS'
                
                for wsock in wsocks:
                    if (wsock.class_name != class_name) or (wsock.bsocket.display_shape != display_shape):
                        self.unames[wsock.name] = wsocks
                        distinction = 'SHARED'
                        break
                    
                if distinction == 'HOMONYMS':
                    if wsocks[0].is_output:
                        raise RuntimeError("Big mistake !!!")
                    for i, wsock in enumerate(wsocks):
                        wsock.uname = f"{name}{i}"
                        self.unames[wsock.uname] = wsock
                        
        # ----- unames indices
        # - key     : the unique name
        # - value   : a dictionay giving the socket index from the driving
        #             parameter value
        # Initialized by the owner node by making vary the driving parameter
        # and by calling the method update_unames_indices
        #
        # Example:
        # unames_indices = {'from_value': {'FLOAT': 0, 'VECTOR': 2}, 'to_value': {'FLOAT': 1, 'VECTOR' : 3}}

        self.unames_indices = {}
        for uname in self.unames:
            self.unames_indices[uname] = {}
            
    # ----------------------------------------------------------------------------------------------------
    # The sockets which are shared according a driving parameter                 
                        
    @property
    def shared_sockets(self):
        sel = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                sel[uname] = wsocks
        return sel
    
    # ----------------------------------------------------------------------------------------------------
    # The node makes vary the driving parameter. At each change, it calls the following
    # method to update the unames_indices dictionary
        
    def update_unames_indices(self, param_value):
        for uname, wsocks in self.shared_sockets.items():
            for wsock in wsocks:
                if wsock.enabled:
                    if self.unames_indices[uname].get(param_value) is not None:
                        raise RuntimeError("Unconsistant, really !")
                    self.unames_indices[uname][param_value] = wsock.index
    

    # ----------------------------------------------------------------------------------------------------
    # Get the currently enabled sockets
    
    def enabled_sockets(self):
        wsockets = []
        for wsock in self:
            if wsock.enabled:
                wsockets.append(wsock)
        return wsockets
    
    # ====================================================================================================
    # Output sockets indices
    # Used to build the output_sockets property of the generated class
    
    def get_socket_indices(self, fixed):
        inds = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                index = self.unames[uname][fixed[self.driving_param]]
            else:
                index = wsocks.index
            inds[uname] = index
        return inds
    
    
# ====================================================================================================
# A parameter wrapper

class Parameter:
    def __init__(self, wnode, name):
        self.wnode   = wnode
        self.name    = name
        self.uname   = name

        self.is_enum    = False  # The parameter value is chosen in an enum list : self.values
        self.default    = self.value
        self.param_type = type(self.default).__name__ 
        
        if isinstance(self.default, bpy.types.bpy_struct):
            self.default = None
        elif isinstance(self.default, mathutils.Vector):
            self.default = list(self.default)
            
        if isinstance(self.default, str):
            try:
                setattr(self.wnode.bnode, self.name, 'ERROR')
                #self.value = 'ERROR'
            except TypeError as e:
                msg = str(e)
                i = msg.find('enum "ERROR" not found in')
                self.is_enum = i > 0
                if self.is_enum:
                    self.values = eval(msg[i+26:])
                    add_enum_list(name, self.values)
                    
                    
        # ----- Some hack :-( 
        
        if self.wnode.bl_idname == 'FunctionNodeCompare' and self.name == 'operation':
            self.values = ('LESS_THAN', 'LESS_EQUAL', 'GREATER_THAN', 'GREATER_EQUAL', 'EQUAL', 'NOT_EQUAL', 'DARKER', 'BRIGHTER')
                    
    def __str__(self):
        vals = str(self.values) if self.is_enum else self.default
        return f"<WNode Parameter {self.name} ({self.uname}): {vals}>"
    
    @property
    def sdefault(self):
        if isinstance(self.default, str):
            return f"'{self.default}'"
        else:
            return self.default
        
    @property
    def value(self):
        return getattr(self.wnode.bnode, self.name)
    
    @value.setter
    def value(self, v):
        try:
            setattr(self.wnode.bnode, self.name, v)
        except:
            pass
            #print(f"CAUTION: error when setting parameter {self.name} with value '{v}'")
        
    def reset(self):
        if self.default is not None:
            self.value = self.default
            
    @property
    def short_values(self):
        s = ""
        ok_pass = True
        for i, value in enumerate(self.values):
            if (len(s) < 30) or (i >= len(self.values)-3):
                s += f", {value}"
            else:
                if ok_pass:
                    s += ',... '
                    ok_pass = False
        return f"[{s[2:]}]"
        
            
# ====================================================================================================
# A node wrapper

class WNode:
    
    WNODES = {}
    
    STD_ATTRS = [
       '__doc__', '__module__', '__slots__', 'bl_description', 'bl_height_default', 'bl_height_max',
       'bl_height_min', 'bl_icon', 'bl_idname', 'bl_label', 'bl_rna', 'bl_static_type',
       'bl_width_default', 'bl_width_max', 'bl_width_min', 'color', 'dimensions', 'draw_buttons',
       'draw_buttons_ext', 'height', 'hide', 'input_template', 'inputs', 'internal_links',
       'is_registered_node_type', 'label', 'location', 'mute', 'name', 'output_template', 'outputs',
       'parent', 'poll', 'poll_instance', 'rna_type', 'select', 'show_options', 'show_preview',
       'show_texture', 'socket_value_update', 'type', 'update', 'use_custom_color',
       'width', 'width_hidden',
       # Ignore for simulation nodes
       'pair_with_output', 'state_items',
       
       ]
    
    def __init__(self, bnode):
        
        #print("NODE bl_idname", bnode.bl_idname)
        
        WNode.WNODES[bnode.bl_idname] = self
        
        self.bnode   = bnode
        self.inputs  = WSockets(self.bnode.inputs)
        self.outputs = WSockets(self.bnode.outputs)
        
        # Output geometry sockets class name can be defined by its name
        # But some socket names need specifif setting
        
        geo_classes = OUTPUT_SOCKETS_CLASS.get(self.bnode.bl_idname, {})
        for wsock in self.outputs:
            class_name = geo_classes.get(wsock.name, None)
            if class_name is not None:
                wsock.class_name = class_name
                
        # Parameters
        
        self.parameters = {}
        for param_name in dir(self.bnode):
            
            # type is valid for Node FunctionNodeRotateEuler
            
            ok_param = not param_name in WNode.STD_ATTRS
            
            # Hacks
            
            if bnode.bl_idname == 'FunctionNodeRotateEuler' and param_name == 'type':
                ok_param = True
                
            # End of hacks
            
            if ok_param:
                param = Parameter(self, param_name)
                if param.default is None:
                    continue
                    
                self.parameters[param_name] = param
                if param_name in self.outputs.unames:
                    self.parameters[param_name].uname = param_name + '_'
                    
        # ----- shared sockets : a unique name is shared between several sockets
                    
        self.has_shared_sockets = bool(self.inputs.shared_sockets) or bool(self.outputs.shared_sockets)
        
        if self.has_shared_sockets:
            self.driving_param = 'input_type' if hasattr(self.bnode, 'input_type') else 'data_type'
            
            # hacks
            if bnode.bl_idname == 'GeometryNodeSampleVolume':
                self.driving_param = 'interpolation_mode'
            
            try:
                param = self.parameters[self.driving_param]
            except:
                raise Exception(f"Impossible de get the driving parameter of '{bnode.bl_idname}'. '{param}' fails. Parameters are {self.parameters}")
            
            
            for value in param.values:
                param.value = value
                self.inputs.update_unames_indices(value)
                self.outputs.update_unames_indices(value)
                
        # ----- Data sockets calling this node
        
        self.data_sockets = {}
                

    def __str__(self):
        return f"[{self.node_name}]"
    
    def register_socket(self, class_name, name, family):
        lst = self.data_sockets.get(class_name)
        if lst is None:
            self.data_sockets[class_name] = [(name, family)]
        else:
            lst.append((name, family))
        
        
    @property
    def bl_idname(self):
        return self.bnode.bl_idname
    
    @property
    def node_name(self):
        
        # ----- Some hacks
        
        if self.bnode.name == "ColorRamp":
            return "ColorRamp"
        
        # ----- Standard
        
        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            if word.lower() == 'id':
                s += 'ID'
            else:
                s += word.capitalize()
        return s
        #return "Node" + s
    
    @property
    def function_name(self):

        # ----- Some hacks
        
        if self.bnode.name == "ColorRamp":
            return "color_ramp"
        
        # ----- Standard

        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            w = word.lower()
            if w == 'id':
                w = 'ID'
            if w in '_':
                s += '_'
            else:
                if s != "":
                    s += '_'
                s += w
        return s
    
    @property
    def blender_ref_name(self):
        return self.bnode.name.lower().replace(' ', '_')
    
    @property
    def blender_ref_menu(self):
        return NODES_MENU[self.blender_ref_name][0]
    
    # ---------------------------------------------------------------------------
    # Blender reference

    @property
    def blender_python_ref(self):
        return f"https://docs.blender.org/api/current/bpy.types.{self.bl_idname}.html"
    
    @property
    def blender_ref(self):
        ref = NODES_MENU.get(self.blender_ref_name)
        if ref is None:
            print(f"OLD CAUTION: key {self.blender_ref_name} not found")
            ref = f"{self.blender_ref_name} not found"
            
        return f"https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/{ref[1]}.html"
    
    @property
    def node_image_ref(self):
        return f"https://docs.blender.org/manual/en/latest/_images/node-types_{self.bnode.bl_idname}.webp"        
    
    # ---------------------------------------------------------------------------
    # Set parameters

    def reset_params(self):
        for param in self.parameters.values():
            param.reset()

    def set_params(self, param_values={}):
        for name, param in self.parameters.items():
            if name in param_values:
                param.value = param_values[name]
            else:
                param.reset()
                
    # ----------------------------------------------------------------------------------------------------
    # Non driving parameters
    
    def non_driving_params(self):
        params = {}
        for name, param in self.parameters.items():
            if name == self.driving_param:
                continue
            params[name] = Parameter(self, name)
        return params
    
    # ----------------------------------------------------------------------------------------------------
    # Node arguments
    
    def get_node_arguments(self):

        args = Arguments()
        for uname, wsock in self.inputs.unames.items():
            args.add(Argument.Socket(uname, wsocket=wsock))
            
        for name, param in self.parameters.items():
            args.append(Argument.Param(name, param.default, param=param))
            
        args.check_order(self.bl_idname)
            
        return args
    
    # ====================================================================================================
    # Enabled sockets with the fixed parameters
    # makes the free parameters vary to check which sockets to use
    
    def sockets_unames(self, wsockets, fixed={}):
    
        self.set_params(fixed)
        
        ens = [wsock.enabled for wsock in wsockets]
        for name, param in self.parameters.items():
            if name in fixed:
                continue
            if not param.is_enum:
                continue
            
            # ----- Reload the enum values to explore the possibilities
            
            new_param = Parameter(self, name)
            for value in new_param.values:
                param.value = value
                for i, wsock in enumerate(wsockets):
                    if wsock.enabled:
                        ens[i] = True
            new_param.value = new_param.default
        
        # ----- Let's keep only the outputs which can be enabled
        
        self.set_params(fixed)

        fixed_shared = True
        if self.has_shared_sockets:
            fixed_shared = self.driving_param in fixed
                
        unames = {}
        for i, wsock in enumerate(wsockets):
            if ens[i] and (wsock.uname not in unames):
                if fixed_shared or wsock.uname not in wsockets.shared_sockets:
                    unames[wsock.uname] = wsock.class_name
                else:
                    unames[wsock.uname] = f"{self.driving_param} dependant"
                    
        return unames

    # ----------------------------------------------------------------------------------------------------
    # Argument sockets

    def input_unames(self, fixed={}):
        return self.sockets_unames(self.inputs, fixed=fixed)
    
    # ----------------------------------------------------------------------------------------------------
    # Returned sockets
    
    def output_unames(self, fixed={}):
        return self.sockets_unames(self.outputs, fixed=fixed)
    
    @property
    def output_sockets_count(self):
        return len(self.output_unames())
    
    # ====================================================================================================
    # Formatting utility
    
    @staticmethod
    def format_list(values, width=100, first_width=None):
        
        if not values:
            return "[]"
        
        is_str = isinstance(values[0], str)
        if first_width is None:
            first_width = width
        w = first_width
        s = "["
        sep = ""
        for i, value in enumerate(values):
            if is_str:
                s += f"{sep} '{value}'"
            else:
                s += "{sep} {str(value)}"
            if len(s) >= w:
                if i == len(values)-1:
                    yield s + "]"
                else:
                    yield s + ","
                s   = ""
                sep = ""
                w   = width
                
        if s != "":
            yield s + "]"
            
    # ====================================================================================================
    # The geometry class
    # Return the geometry class
    
    def output_geometry_class(self):
        s = ""
        for wsock in self.outputs:
            if wsock.class_name in ['Geometry', 'Curve', 'Mesh', 'Points', 'Instances', 'Volume']:
                if wsock.class_name != 'Geometry' and wsock.name.lower() == wsock.class_name.lower():
                    continue
                
                if s == "":
                    sbl = f"'{self.bnode.bl_idname}'"
                    s = f"{sbl:42s} : " + "{"
                sn = f"'{wsock.uname}'"
                s += f"{sn:17s} : '{wsock.class_name}'" + ","
                
        return s if s == "" else s + "}," 
            
    # ====================================================================================================
    # Build the documentation
    
    def documentation(self):

        args = self.get_node_arguments()
        
        # ----- Source code demo
        
        s = args.sheader
        scall = f"node = nodes.{self.node_name}({s}"
        if s != "":
            scall += ", "
        scall += "label=None, node_color=None)"
        
        section = Section(None, f"Node {self.node_name}")
        section.id = self.node_name
        
        section.set_text(f"""
        > Geometry node name: [{self.bnode.name}]({self.blender_ref})<br>
        > Blender type: [{self.bnode.name}]({self.blender_python_ref})
        
        <sub>go to [index](ref:index)</sub>
        
        Initialization
        --------------
        
        ```python
        from geonodes import nodes
        {scall}
        ```
        
        """)
        
        # ----- Arguments
        
        arg_section = Section(section, "Arguments")
    
        if self.inputs:
            
            lst = [""]
            for uname, wsock in self.inputs.unames.items():
                
                if isinstance(wsock, list):
                    sval = f"{self.driving_param} dependant"
                elif wsock.is_multi_input:
                    sval = f"<m> {wsock.class_name}"
                else:
                    sval = f"{wsock.class_name}"
                
                lst.append(f"{uname} : {sval}")
                
            new_section = Section(arg_section, "Input sockets")
            new_section.set_text("\n- ".join(lst))
            
        if self.parameters:
            
            lst = [""]
            for name, param in self.parameters.items():
                
                stype = param.param_type
                if stype == 'str':
                    stype = f"{stype} (default = '{param.default}')"
                else:
                    stype = f"{stype} (default = {param.default})"
                
                if param.is_enum:
                    stype += f" in {param.values}"
                    
                lst.append(f"{name} : {stype}")
                
            new_section = Section(arg_section, "Parameters")
            new_section.set_text("\n- ".join(lst))
            
        new_section = Section(arg_section, "Node label")
        new_section.set_text(
            f"- label : Geometry node display label (default=None)\n" +
            f"- node_color : Geometry node color (default=None)")
            
        
        # ----- Data type dependant sockets
                    
        if self.has_shared_sockets:
            
            new_section = Section(section, "Data type dependant sockets")
            new_section.set_text(f"""
                                 
            - Driving parameter : {self.driving_param} in {self.parameters[self.driving_param].values}
            - Input sockets  : {list(self.inputs.shared_sockets.keys())}
            - Output sockets : {list(self.outputs.shared_sockets.keys())}   
                              
            """)

        # ----- Output sockets
    
        if self.outputs:
            lst = [""]
            for uname, wsock in self.outputs.unames.items():
                
                if isinstance(wsock, list):
                    sval = f"{self.driving_param} dependant"
                else:
                    sval = wsock.class_name
                    if wsock.is_multi_input:
                        sval += "(multi input)"
                
                lst.append(f"{uname} : {sval}")
                
            new_section = Section(section, "Output sockets")
            new_section.set_text("\n- ".join(lst))
                
        # ----- Data classes
        
        if self.data_sockets:
            
            lst = [""]
            for class_name in sorted(self.data_sockets):
                refs = sorted(self.data_sockets[class_name], key=lambda nf: nf[0])
                for meth_name, family in refs:
                    lst.append(f"[{class_name}](id:{class_name}).[{meth_name}](id:{class_name}#{meth_name}) : {family}")
                    
            new_section = Section(section, "Data sockets")
            slst = "\n- ".join(lst)
            new_section.set_text(f"> Data socket classes implementing this node.\n\n{slst}\n")
        
        return section
    
    # ====================================================================================================
    # Generated the mark down documentation
    #
    # Generation start after header 1 is generated
    
    def gen_markdown_doc(self):
        
        args = self.get_node_arguments()
        
        # ----------------------------------------------------------------------------------------------------
        # References
        
        yield f"- [Blender reference]({self.blender_ref})\n"
        yield f"- [api reference]({self.blender_python_ref})\n"
        yield f"- geonodes name: `{self.node_name}`\n"
        yield f"- bl_idname: `{self.bnode.bl_idname}`\n\n"
        
        yield "```python\n"
        yield "from geonodes import nodes\n\n"
        yield f"node = nodes.{self.node_name}({args.sheader})\n"
        yield "```\n\n"
        
        yield f"![Blender Image]({self.node_image_ref})\n\n"
        
        # ----------------------------------------------------------------------------------------------------
        # Input sockets
        
        ok_args = False
        
        ok_header = False
        for uname, wsock in self.inputs.unames.items():
            
            if not ok_args:
                yield "### Args:\n\n"
                ok_args = True
            
            if not ok_header:
                yield "#### Input socket arguments:\n\n"
                ok_header = True
                
            yield f"- **{uname}**: "
            
            if isinstance(wsock, list):
                yield f"**{self.driving_param}** dependant"
                
            elif wsock.is_multi_input:
                yield f"*[{wsock.class_name}]({wsock.class_name}.md)"
                
            else:
                yield f"[{wsock.class_name}]({wsock.class_name}.md)"
                
            yield "\n"
            
        if ok_header:
            yield "\n"
            
        # ----------------------------------------------------------------------------------------------------
        # Node parameters
        
        ok_header = False
        for name, param in self.parameters.items():
            
            if not ok_args:
                yield "### Args:\n\n"
                ok_args = True
            
            if not ok_header:
                yield "#### Node parameter arguments:\n\n"
                ok_header = True
            
            stype = param.param_type
            if stype == 'str':
                descr =f"default = '{param.default}'"
                
            else:
                descr =f"default = {param.default}"
            
            if param.is_enum:
                descr += f" in {param.values}"
                
            yield f"- **{name}** ({stype}): {descr}\n"
            
        if ok_header:
            yield "\n"
            
        # ----------------------------------------------------------------------------------------------------
        # Output sockets
        
        if self.outputs:
            yield "### Output sockets:\n\n"
            for uname, wsock in self.outputs.unames.items():
                
                if isinstance(wsock, list):
                    sval = f"``{self.driving_param}`` dependant"
                else:
                    sval = f"[{wsock.class_name}]({wsock.class_name}.md)"
                        
                yield f"- **{uname}** : {sval}\n"
                
            yield "\n"
            
        # ----------------------------------------------------------------------------------------------------
        # Shared sockets
        
        if self.has_shared_sockets:
            
            yield "#### Shared sockets:\n\n"
            
            yield f"- Driving parameter : ``{self.driving_param}`` in {self.parameters[self.driving_param].values}\n"
            yield f"- Input sockets  : {list(self.inputs.shared_sockets.keys())}\n"
            yield f"- Output sockets : {list(self.outputs.shared_sockets.keys())}\n"
    

    # ====================================================================================================
    # Generate the node class
    
    def gen_node_class(self, wrap_parameters=True, cl_gen=None):
        
        args = self.get_node_arguments()
        
        # ---------------------------------------------------------------------------
        # Class header
        #
        # class NodeMath(Node):
        
        yield _0_ + f"class {self.node_name}(Node):\n"
    
        # ---------------------------------------------------------------------------
        # Class comment
        
        yield _1_ + '"""' + f"Node *{self.bnode.name}*\n"
        yield _1_ + f".. _{self.node_name}:\n"
        
        # ---- Classes calling this node
        
        if cl_gen is not None:
            node_ref = cl_gen.get(self.bl_idname)
            if node_ref is None:
                pass
                #print(f"CAUTION: node {self.bl_idname} not implemented in class generators")
                
            else:
                yield _1_ + "Node implementation:"
                for class_name, gs in node_ref.items():
                    if class_name == 'functions':
                        yield _2_ + 'global functions:'
                    else:
                        yield _2_ + f"{class_name}:"
                        
                    gens = gs if isinstance(gs, list) else [gs]
                    nref = 0
                    sref = _3_
                    for gen in gens:
                        sref += gen.fname(self) + " "
                        nref += 1
                        if nref % 10 == 0:
                            yield sref
                            nref = 0
                            sref = _3_
                    if nref > 0:
                        yield sref

                yield "\n"
            
        # ----- Arguments
        
        yield _1_ + "Args:"
        
        for uname, wsock in self.inputs.unames.items():
            
            if isinstance(wsock, list):
                sval = f"``{self.driving_param}`` dependant"
            elif wsock.is_multi_input:
                sval = f"<m> {wsock.class_name}"
            else:
                sval = f"{wsock.class_name}"
                
            yield _2_ + f"{uname} (DataSocket): {sval}"
            
        for name, param in self.parameters.items():
            
            stype = param.param_type
            if stype == 'str':
                descr =f"Node parameter, default = '{param.default}'"
            else:
                descr =f"Node parameter, default = {param.default}"
            
            if param.is_enum:
                descr += f" in {param.values}"
                
            yield _2_ + f"{name} ({stype}): {descr}"
        
        yield _2_ + "node_color (color): Node color"
        yield _2_ + "node_label (str): Node label"
        yield _0_
        
        if self.outputs:
            yield _0_ + _1_ + "Output sockets:"
            for uname, wsock in self.outputs.unames.items():
                
                if isinstance(wsock, list):
                    sval = f"``{self.driving_param}`` dependant"
                else:
                    sval = wsock.class_name
                        
                yield _2_ + f"- **{uname}** : {sval}"
                
        
        if self.has_shared_sockets:
            
            yield _0_ + _1_ + "Shared sockets:"
                                     
            yield _2_ + f"- Driving parameter : ``{self.driving_param}`` in {self.parameters[self.driving_param].values}"
            yield _2_ + f"- Input sockets  : {list(self.inputs.shared_sockets.keys())}"
            yield _2_ + f"- Output sockets : {list(self.outputs.shared_sockets.keys())}"
            
        yield _0_ + _1_ + f".. blid:: {self.bl_idname}"
                
        yield _0_ + _1_ + '"""' + "\n"
            
            
    
        # ---------------------------------------------------------------------------
        # Constructor __init__
        #
        # def __init__(self, input sockets, param sockets, label):
    
        yield _1_ + "def __init__(self"
        s = args.sheader
        if s != "":
            yield ", " + s
        yield ", label=None, node_color=None):\n"
    
        # ---------------------------------------------------------------------------
        # Call of super
        #
        # super().__init__(bl_idname, name, label)
        
        yield _2_ + f"super().__init__('{self.bl_idname}', node_name='{self.bnode.name}', label=label, node_color=node_color)\n"

        # ---------------------------------------------------------------------------
        # Parameters
        #
        # self.bnode.data_type = data_type
        
        yield_comment = True
        for name, param in self.parameters.items():
            if yield_comment:
                if self.has_shared_sockets:
                    yield _2_ + "# Node parameters to configure the sockets enablement\n"
                else:
                    yield _2_ + "# Node parameters\n"
                yield_comment = False
                
            # self.param = arg
            
            # OLD: call value_data_type for data_type attribute
            if False:
                if self.has_shared_sockets and param.name == self.driving_param:
                    
                    socket_name = None
                    for uname, wsocks in self.inputs.unames.items():
                        if isinstance(wsocks, list):
                            socket_name = uname
                    if socket_name is None:
                        yield _2_ + f"self.bnode.{param.name:15s} = {name}"
                        #raise RuntimeError(f"None, {self}: No uname found for the the driving param '{param.name}'")
                    else:
                        yield _2_ + f"self.bnode.{param.name:15s} = self.value_data_type({socket_name}) if {name} is None else {name}"
                    
                else:
                    yield _2_ + f"self.bnode.{param.name:15s} = {name}"
                    
            # NEW: call check_enum_value for all enum values
            else:
                if param.is_enum:
                    yield _2_ + f"self.bnode.{param.name:15s} = self.check_enum_value({name}, '{param.name}', {param.values}, '{param.default}')"
                else:
                    yield _2_ + f"self.bnode.{param.name:15s} = {name}"
                
                
        
        if not yield_comment:
            yield "\n"
            
        # ---------------------------------------------------------------------------
        # Input and output socket unique names towards indices
        # Node insockets and outsockets provide the index (or list of indices) for each socket uname
        # - outsockets is used by getattr to get the output sockets by their name
        # - insockets is used by setattr to plug in input sockets
        #self.insockets  = {}
        #self.outsockets = {}
        
        yield _2_ + "# Input and output sockets names (for use in __getattr__ and __setattr__)\n"
        
        yield _2_ + "self.insockets = {"
        for uname, wsocks in self.inputs.unames.items():
            if isinstance(wsocks, list):
                yield f"'{uname}' : {[ws.index for ws in wsocks]}, "
            else:
                yield f"'{uname}' : {wsocks.index}, "
        yield "}"
        
        
        yield _2_ + "self.outsockets = {"
        for uname, wsocks in self.outputs.unames.items():
            if isinstance(wsocks, list):
                yield f"'{uname}' : {[ws.index for ws in wsocks]}, "
            else:
                yield f"'{uname}' : {wsocks.index}, "
        yield "}\n"
        
        # ---------------------------------------------------------------------------
        # Output sockets class
        
        out_classes = OUTPUT_SOCKETS_CLASS.get(self.bnode.bl_idname, None)
        if out_classes is not None:
            yield _2_ + "# Force class of output sockets\n"
            yield _2_ + f"self.outsockets_classes = {out_classes}\n"

        # ---------------------------------------------------------------------------
        # Now that the insockets are declared, we can set the input sockets
        
        yield_comment = True
        for uname, wsocks in self.inputs.unames.items():
            if yield_comment:
                yield _2_ + "# Input sockets plugging\n"
                yield_comment = False
                
            # Multi input hack
            if not isinstance(wsocks, list):
                if wsocks.is_multi_input:
                    yield _2_ + f"self.plug({wsocks.index}, *{uname})"
                    continue
            
            yield _2_ + f"if {uname:15s} is not None: self.{uname:15s} = {uname}"

        if not yield_comment:
            yield "\n"
    
        # ---------------------------------------------------------------------------
        # Wrap the parameters
        
        if wrap_parameters:
            for name, param in self.parameters.items():
                yield _1_ +  "@property"
                yield _1_ + f"def {param.uname}(self):"
                yield _2_ + f"return self.bnode.{name}\n"
            
                yield _1_ + f"@{param.uname}.setter"
                yield _1_ + f"def {param.uname}(self, value):"
                yield _2_ + f"self.bnode.{name} = value\n"
                
        # ---------------------------------------------------------------------------
        # Output sockets
        
        for name, wsock in self.outputs.unames.items():
            yield _1_ + "@property"
            yield _1_ + f"def {name}(self):"
            yield _2_ + f"return self.get_output_socket('{name}')\n"
            
        # ---------------------------------------------------------------------------
        # Input sockets
        
        for name in self.inputs.unames:
            if name not in self.outputs.unames:
                yield _1_ + "@property"
                yield _1_ + f"def {name}(self):"
                s = f"Attribute error on node '{self.node_name}': the input socket '{name}' is write only."
                yield _2_ + 'raise AttributeError("' + s + '")\n'
                
            yield _1_ + f"@{name}.setter"
            yield _1_ + f"def {name}(self, value):"
            yield _2_ + f"self.set_input_socket('{name}', value)\n"

        
# ====================================================================================================
# Create a tree with all the possible nodes

class BNodes(dict):
    
    def __init__(self):
        print("Collecting the available geometry nodes...")        
        super().__init__()

        btree_nodes = bpy.data.node_groups["Geometry Nodes"].nodes
        btree_nodes.clear()

        for tp in dir(bpy.types):
            
            if tp in DEPRECATED:
                continue
            
            if tp.find('Legacy') < 0:
                try:
                    bnode = btree_nodes.new(tp)
                except:
                    continue
                self[tp] = bnode
            
                

# ====================================================================================================
# Generate the files

# ----------------------------------------------------------------------------------------------------
# Generate the classes
# 
# When a classes is created, it update the nodes it uses
                
def create_data_sockets(fpath):
    
    # ----- sockets files

    gsock.GEN_NODES = []
    class_gens = []
    
    nodes_md = {}
    
    # ---------------------------------------------------------------------------
    # Loop on the data sockets generators

    for i, dgen in enumerate(gsock.DATA_CLASSES):
        
        class_gen = dgen(WNode.WNODES)
        class_gens.append(class_gen)
        
        with open(fpath + f"sockets/{class_gen.class_name.lower()}.py", 'w') as f:

            for line in class_gen.gen_class():
                f.write(line)
                
            f.write("\n\n")
            
        class_gen.register_nodes()
        
        # ----------------------------------------------------------------------------------------------------
        # Add the class documentation to the global doc
        
        sockets_doc.add_section(class_gen.class_doc)

        # ----- For further indexing
                
        #generated_sockets.append(class_gen.class_name)


# ----------------------------------------------------------------------------------------------------
# Create all the nodes

def create_nodes(fpath, BNODES):
    
    fname = fpath + "nodes/nodes.py"
    
    with open(fname, 'w') as f:
        
        QUOTES = '"""'
        
        f.write(f"""#!/usr/bin/env python3
# -*- coding: utf-8 -*-

{QUOTES}
Created on {date.today()}

@author: Generated from generator module

Blender version: {bpy.app.version_string}
{QUOTES}

from geonodes.core.node import Node

""")

        creation = []
        for bnode in BNODES.values():
            
            # ----------------------------------------------------------------------------------------------------
            # Load the node
            
            wn = WNode.WNODES[bnode.bl_idname]
            
            # ----- Some exclusion
            
            if wn.bl_idname in ['NodeReroute', 'NodeGroupInput', 'NodeGroupOutput', 'NodeFrame']:
                continue
            
            # ----- Write the node
            
            f.write(f"\n# {'-'*100}\n")
            f.write(f"# Node {wn.node_name} for {wn.bl_idname}\n")
            

            for line in wn.gen_node_class(cl_gen=code_gen.ALL):
                f.write(line)
                    
            # ----- For creation by bl_idname
            
            creation.append(f"'{wn.bl_idname}': {wn.node_name}") 
            
        # ----- A function to create a node from the bl_idname
        
        f.write(f"# {'-'*80}\n")
        f.write("# Create node from its bl_idname\n\n")
        
        f.write( "def create_node(bl_idname, *args, **kwargs):\n")
        sdict = ",\n    ".join(creation)
        O = "{"
        C = "}"
        f.write(f"    nodes = {O}{sdict}{C}\n")
        f.write( "    return nodes[bl_idname](*args, **kwargs)\n\n")
        
        
# ====================================================================================================
# Build geonodes auto doc

def build_geonodes_auto_doc(fpath):
    
    Module = pyparser.Module
    
    #arrange     = Module(fpath + file_name="core/arrange.py"),
    #colors      = Module(fpath + file_name="core/colors.py"),
    #context     = Module(fpath + file_name="core/context.py"),

    datasockets = Module(fpath + "core/datasockets.py")
    domain      = Module(fpath + "core/domain.py")
    node        = Module(fpath + "core/node.py",      ['Group', 'Frame'])
    socket      = Module(fpath + "core/socket.py",    ['DataSocket'])
    tree        = Module(fpath + "core/tree.py",      ['Tree', 'Trees'])
    
    classes     = Module(fpath + "nodes/classes.py",  'ALL')
    domains     = Module(fpath + "nodes/domains.py",  'ALL')
    
    class_docs  = Module(fpath + "core/class_docs.py")
    functions   = Module(fpath + "nodes/functions.py")
    
    modules = [datasockets, domain, node, socket, tree, classes, domains, functions]
    
    # ----- Complementory doc
    
    classes.inherits(['Mesh', 'Curve', 'Points', 'Instances', 'Volume'], None, class_docs)
    domains.inherits(['Vertex', 'Edge', 'Face', 'Corner', 'ControlPoint', 'Spline', 'CloudPoint'], None, class_docs)
    
    # ----- Datasockets inherits
    
    socket.inherits('DataSocket', 'Socket')
    datasockets.add_inheritance(
        ['Boolean', 'IntFloat', 'Vector', 'Color', 'String',
         'Geometry',
         'Collection', 'Object', 'Material', 'Texture', 'Image'],
        super_classes = 'DataSocket',
        super_module  = socket,
        )
    datasockets.inherits(['Float', 'Integer'], 'IntFloat')
    
    # ----- Final data classes

    classes.inherits(
        ['Boolean', 'Integer', 'Float', 'Vector', 'Color', 'String',
         'Geometry',
         'Collection', 'Object', 'Material', 'Texture', 'Image'],
        super_classes = None,
        super_module  = datasockets,
        )

    classes.inherits(
        ['Mesh', 'Curve', 'Instances', 'Points', 'Volume'],
        super_classes = 'Geometry',
        super_module  = None,
        )
    
    # ----- Nodes inherits
    
    node.inherits(['Frame', 'CustomGroup', 'SceneTime'], 'Node')
    node.inherits(['Group','GroupInput', 'GroupOutput'], 'CustomGroup')
    
    # ----- Domains inherits
    
    domains.inherits('Domain', 'Domain', domain)
    domains.inherits(
        ['Vertex', 'Edge', 'Face', 'Corner', 'ControlPoint', 'Spline', 'CloudPoint', 'Instance'],
        super_classes = 'Domain',
        super_module  = None
        )
    
    
    # ----- Update the documentation
    
    for module in modules:
        if module.name == 'functions':
            with open(fpath + "docs/api/functions.md", 'w') as f:
                f.writelines([line for line in module.functions.gen_markdown()])
            
        else:
            for class_name in module.documented_classes:
                #print(f"Documentation of {class_name}")
                with open(fpath + f"docs/api/{class_name}.md", 'w') as f:
                    f.writelines(module.markdown(class_name))
                    
# ====================================================================================================
# Check the classes of geometry output sockets

def check_output_geometry_classes():
    
    BNODES = BNodes()

    for bnode in BNODES.values():
        wn = WNode(bnode)
        s = wn.output_geometry_class()
        if s != "":
            print(s)
    
    
                    
                
                    
# ====================================================================================================
# Generate the nodes module
                
def create_geonodes(fpath, version, print_enums=False):
    
    gn_version = bpy.app.version + (version,)
    
    print("-"*80)
    print("Generating nodes and sockets python from Blender geometry nodes")
    print(f"Blender version: {bpy.app.version_string}")
    print(f"Geonode version: {gn_version}")
    print("")
    
                
    # ----- Create all the blender nodes
    
    BNODES = BNodes()

    # ----- Create all the wrappers
    
    print("Create nodes layer...")

    for bnode in BNODES.values():
        WNode(bnode)
        
    create_nodes(fpath, BNODES)
        
    # ----- Generate the classes
    
    print("Create data classes...")
        
    cg = code_gen.get_class_generators(WNode.WNODES)
    cg.create_files(fpath, version=gn_version)
    
    print("Create documentation...")

    cg.create_nodes_menus(fpath)
    build_geonodes_auto_doc(fpath)               
    
    print("Create test file...")

    cg.create_test_file(fpath)
    
    print("Done")
    print()
    
    print(f"Version {gn_version} completed")
    print()
    print("Import geonodes.test_file to test the generation")
    print()
    print('-'*80)
    print("NOTE: if new nodes are created, don't forget to run node_sizes():")
    print("Node dimensions are intizalized to zero. To update the property correctly, go")
    print("in the geometry nodes editor and then back to the script editor.")
    print("Lauch generator.node_sizes() WITHOUT LAUNCHING create_geonodes AGAIN!")
    print("... hope it works.")
    
    if print_enums:
        print_all_enums()

# ====================================================================================================
# Generate the nodes module
                    
def node_sizes():
    print()
    print("Node sizes (to include in module 'arrange.py'")
    print("To collect the proper size calls this function once they have been generated with create_geonodes")
    print()
    
    
    btree_nodes = bpy.data.node_groups["Geometry Nodes"].nodes
    for bnode in btree_nodes:
        s = f"'{bnode.bl_idname}'"
        pat = r"\([^\)]*\)"
        print(f"    {s:42s}: {re.findall(pat, str(bnode.dimensions))[0]},")
        
    print()
    
# ====================================================================================================
# Take the nodes details for future comparison

def finger_print(fpath=None):

    version = bpy.app.version_string
    print("="*80)
    print(f"Taking finger print of geometry nodes, Blender version: {version}")
    print()

    btree_nodes = bpy.data.node_groups["Geometry Nodes"].nodes
    btree_nodes.clear()
    
    # ----- Read the nodes
    
    nodes = {'VERSION': version}

    for tp in dir(bpy.types):
        
        if tp in DEPRECATED:
            continue
        
        if tp.find('Legacy') < 0:
            try:
                bnode = btree_nodes.new(tp)
            except:
                continue
            
            wnode = WNode(bnode)
            
            nodes[tp] = {
                'inputs'  : [(socket.name, socket.bl_idname) for socket in bnode.inputs],
                'outputs' : [(socket.name, socket.bl_idname) for socket in bnode.outputs],
                'params'  : [name for name in wnode.parameters]
                }
            
    # ----- Write in file and compare to last
            
    if fpath is not None:
    
        # ----- Write
            
        with open(f"{fpath}version {version}.txt", 'w') as f:

            f.write(pformat(nodes, width=80))
            
        # ----- Load last
            
        with open(f"{fpath}version last.txt", 'r') as f:
            last = eval(f.read())
            
        # ----- Comparizon
            
        new_nodes = []
        mod_nodes = []
        
        print()
        print('-'*80)
        print(f"Changes compared to last version {last['VERSION']}")
        print()
        count = 0
            
        for new_name, new_node in nodes.items():
            
            if new_name == 'VERSION':
                continue
            
            old_node = last.get(new_name)
            if old_node is None:
                count += 1
                new_nodes.append(new_name)
                continue
            
            ok = True
            for k in ['inputs', 'outputs', 'params']:
                if new_node[k] != old_node[k]:
                    
                    print(f"   Changes {k:7s} {new_name}")

                    diff = []
                    for v in old_node[k]:
                        if v not in new_node[k]:
                            diff.append(v)
                    print("     Suppressed: ", diff)
                        
                    diff = []
                    for v in new_node[k]:
                        if v not in old_node[k]:
                            diff.append(v)
                    print("     Created   : ", diff)
                    print()
                    
                    mod_nodes.append(new_name)
                    count += 1
                    
        # ----- Synthesis of changes
                    
        print()
        print('-'*80)
        print("Synthesis")
        print()
        
        if count == 0:
            print("> No change")
            print()

        else:
            if mod_nodes:
                print("> Modified nodes:")
                for name in mod_nodes:
                    print(f"     {name}")
                print()
                
            if new_nodes:
                print("> New nodes:")
                for name in new_nodes:
                    print(f"     {name}")
                print()
            
        print("Done")
        
    # ----- Done
        
    return nodes
    

    
