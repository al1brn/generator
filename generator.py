#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun May 29 12:31:31 2022

@author: alain

Generate geonodes Blender addon

====================================================================================================
Description

The geonodes implements two layers:
    - Nodes layer
        One class per geometry nodes, for instance AlignEulerToVector wraps the node FunctionNodeAlignEulerToVector
        The Node class initialization creates the geometry nodes
    - Sockets layer
        One class per data type:
            Basis data: Boolean, Integer, Float, Vector, Color, String
            Geometry  : Geometry, Spline, Curve, Mesh, Point, Instance, Volume
            Special   : Collection, Object, Material, Texture, Image
        The methods and properties of the sockets are implemented by creating nodes:
            circle = Mesh.Circle(radius=2.) --> creates the node GeometryNodeMeshCircle
            
A node accepts data sockets as inputs and return data sockets as ouputs
In addition, it can take parameters

====================================================================================================
Use

In a Blender project, create a Geometry nodes modifier and run the following script

from generator.generator import gen_geonodes

gen_geonodes(fpath)

where fpath is the folder into which generating the files


====================================================================================================
geonodes is made of following structure

----------------------------------------------------------------------------------------------------
----- geonodes.core

----- geonodes.core.node

Tree        : Blender NodeTree wrapper
DataSocket  : Root class for socket wrappers
Node        : Root class for blender geometry nodes wrappers

Some specific nodes are implemented in this module
They are used by Tree:
    
NodeGroup   : Root for GroupInput and GroupOutput

GroupInput  : Wrapper for node NodeGroupInput
              property: tree.group_input
              
GroupOutput : Wrapper for node NodeGroupOutput
              property: tree.group_output
              
Viewer      : Wrapper for node GeometryNodeViewer
              One viewer per tree. Data sockets can use the method to_viewer()
              
Frame       : Wrapper for node NodeFrame
              Tree implemenents new_layout() and close_layout() using Frame

SceneTime   : Wrapper for GeometryNodeInputSceneTime        


----- geonodes.core.datasockets

Implements the base class for DataSockets
All the classes are base on geonode.node.DataSocket

For geometry data, only the class Geometry is implemented in this module
The final classes will be created in geonodes.sockets with the following inheritance

Geometry
    - Spline
        - Curve
    - Mesh
        - Points
        - Instance
        - Volume
        
----- geonodes.core.colors

Some colors constants

----- geonodes.core.arrange

arrange function locates the nodes to make the whole tree somehow readable
It works independantly of the geonodes structure and just take the name
of the NodeTree as an argument.

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.nodes

All he nodes generated by the generator

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.sockets

One file per data socket class plus functions.py which contains the global functions

----------------------------------------------------------------------------------------------------
----- geonodes.__init__.py

The pack initi file contains

====================================================================================================

Generation principle

The generation module is designed to ease the updates with the new versions of geometry nodes

Step 1
------
    try to create all the possible nodes by listing all the types in bpy.types:
    
    for type_name in dir(bpy.types):
        try:
            node = nodes.new(type_name)
        except:
            continue
        
        # We have a valid type
        
    The legacy nodes are excluded from the scane
    
Step 2
------
    Each node is analyzed by:
        - Identifying the parameters (non standard attributes)
            Three types of parameters are possible:
                - Non settable parameters, for instance the color selector of an input color node
                - Enum parameters: str param with a list of valid values
                - Non enum settable parameters, the resolution of a circle for instance
            The settable parameters will be part of the node creation argument
        
        - Identifying if the node has "shared sockets"
            Shared sockets are sockets of different types but sharing the same name.
            Only one socket is enabled at a time, depending upon a "driving parameter"
            Example: node FunctionNodeCompare:
                    - Driving parameter : data_type in ('FLOAT', 'INT', 'VECTOR', 'STRING', 'RGBA')
                    - Input sockets     : ['a', 'b']
                    a and b are names shared by sockets of type Float, Integer, Vector, String and Color
                    
        - Renaming sockets homonyms when exist
            For instance node ShaderNodeMath has three input sockets named Value. They are renamed
            value0, value1 and value2
                    
Step 3
------
    file nodes.py generation in folder geonodes.nodes
    
    The __init__ method of the node class is the concatenation of the input sockets and the settable parameters
    
    for instance, the __init__ method of ShaderNodeMath is:
        
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD'):
            
            The node has 3 sockets and one parameter named operation.
            The default value 'ADD' is the one of the parameter at creation time.
            When a socket has the value None, it is left unplugged.
            A socket can be either a value or data socket class. If it is a value, it
            must be an acceptable default value for the input socket.
            
    An additional argument label is used to allow the user to change the node label:
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD', label=None):
            
Step 4
------
    Generation of the data sockets classes.
    
    A data socket basically wraps an output node socket.
    The methods of a data class consist in creating a node and to plug the socket to one
    input socket of this node.
    
    Example:
        Let use x as a Float which is the output socket of a node.
        We can write:
            
            y = x ** 3
            
        This will create the node ShaderNodeMath with the following parameters:
            
            node = Math(value0=self, value1=3, operation='POWER')
            return node.value
        
    Implementation types
    ---------------------
    
    Depending on their behaviors, the nodes can be implented in the following ways:
        
        Constructor
        -----------
            For nodes which don't transform a socket but create new data
            
            Example: GeometryNodeMeshCircle is implemented as a Mesh constructor
            
            @classmethod
            def Circle(cls, vertices=None, radius=None, fill_type='NONE'):
                return cls(nodes.MeshCircle(vertices=vertices, radius=radius, fill_type=fill_type).mesh)
            
        Property
        --------
            For node which return info on data sockets. The properties are kept in local attributes:
                
                self.prop_ = ... node creation
                return self.prop_
            
            Example: GeometryNodeBoundBox returns 3 infos on the geometry : bounding_box, min and max


"""

from datetime import date
import re

import bpy
import mathutils
from pprint import pprint, pformat

from generator import gen_sockets as gsock
from generator.documentation import Doc, Section, Text
from generator.pyparser import Parser

import importlib
importlib.reload(gsock)

NODES_MENU = {
    "index"                      : ("attribute"                 , "attribute/index"                       ),
    "attribute_statistic"        : ("attribute"                 , "attribute/attribute_statistic"         ),
    "capture_attribute"          : ("attribute"                 , "attribute/capture_attribute"           ),
    "domain_size"                : ("attribute"                 , "attribute/domain_size"                 ),
    "transfer_attribute"         : ("attribute"                 , "attribute/transfer_attribute"          ),
    "store_named_attribute"      : ("attribute"                 , "attribute/store_named_attribute"       ),
    "remove_named_attribute"     : ("attribute"                 , "attribute/remove_named_attribute"      ),
    
    "color_ramp"                 : ("color"                     , "color/color_ramp"                      ),
    "colorramp"                  : ("color"                     , "color/color_ramp"                      ),
    
    "combine_rgb"                : ("color"                     , "color/combine_rgb"                     ),
    
    "mix_rgb"                    : ("color"                     , "color/mix_rgb"                         ),
    "mix"                        : ("color"                     , "color/mix_rgb"                         ),

    "rgb_curves"                 : ("color"                     , "color/rgb_curves"                      ),
    "separate_rgb"               : ("color"                     , "color/separate_rgb"                    ),

    "curve_length"               : ("curve"                     , "curve/curve_length"                    ),
    "curve_to_mesh"              : ("curve"                     , "curve/curve_to_mesh"                   ),
    "curve_to_points"            : ("curve"                     , "curve/curve_to_points"                 ),
    "fill_curve"                 : ("curve"                     , "curve/fill_curve"                      ),
    "fillet_curve"               : ("curve"                     , "curve/fillet_curve"                    ),
    "resample_curve"             : ("curve"                     , "curve/resample_curve"                  ),
    "reverse_curve"              : ("curve"                     , "curve/reverse_curve"                   ),
    "sample_curve"               : ("curve"                     , "curve/sample_curve"                    ),
    "subdivide_curve"            : ("curve"                     , "curve/subdivide_curve"                 ),
    "trim_curve"                 : ("curve"                     , "curve/trim_curve"                      ),
    
    "curve_handle_position"      : ("curve"                     , "curve/curve_handle_position"           ),
    "curve_handle_positions"     : ("curve"                     , "curve/curve_handle_position"           ),

    "curve_tangent"              : ("curve"                     , "curve/curve_tangent"                   ),
    "curve_tilt"                 : ("curve"                     , "curve/curve_tilt"                      ),
    "endpoint_selection"         : ("curve"                     , "curve/endpoint_selection"              ),
    "handle_type_selection"      : ("curve"                     , "curve/handle_type_selection"           ),
    "is_spline_cyclic"           : ("curve"                     , "curve/is_spline_cyclic"                ),
    "spline_length"              : ("curve"                     , "curve/spline_length"                   ),
    "spline_parameter"           : ("curve"                     , "curve/spline_parameter"                ),
    "spline_resolution"          : ("curve"                     , "curve/spline_resolution"               ),
    "set_curve_radius"           : ("curve"                     , "curve/set_curve_radius"                ),
    "set_curve_tilt"             : ("curve"                     , "curve/set_curve_tilt"                  ),
    "set_handle_positions"       : ("curve"                     , "curve/set_handle_positions"            ),
    "set_handle_type"            : ("curve"                     , "curve/set_handle_type"                 ),
    "set_spline_cyclic"          : ("curve"                     , "curve/set_spline_cyclic"               ),
    "set_spline_resolution"      : ("curve"                     , "curve/set_spline_resolution"           ),
    "set_spline_type"            : ("curve"                     , "curve/set_spline_type"                 ),
    "index"                      : ("curve_primitives"          , "curve_primitives/index"                ),
    "arc"                        : ("curve_primitives"          , "curve_primitives/arc"                  ),
    "bezier_segment"             : ("curve_primitives"          , "curve_primitives/bezier_segment"       ),
    "curve_circle"               : ("curve_primitives"          , "curve_primitives/curve_circle"         ),
    "curve_line"                 : ("curve_primitives"          , "curve_primitives/curve_line"           ),
    
    "curve_spiral"               : ("curve_primitives"          , "curve_primitives/curve_spiral"         ),
    "spiral"                     : ("curve_primitives"          , "curve_primitives/curve_spiral"         ),
    
    "quadratic_bezier"           : ("curve_primitives"          , "curve_primitives/quadratic_bezier"     ),
    "quadrilateral"              : ("curve_primitives"          , "curve_primitives/quadrilateral"        ),
    "star"                       : ("curve_primitives"          , "curve_primitives/star"                 ),

    "bounding_box"               : ("geometry"                  , "geometry/bounding_box"                 ),
    "convex_hull"                : ("geometry"                  , "geometry/convex_hull"                  ),
    "delete_geometry"            : ("geometry"                  , "geometry/delete_geometry"              ),
    "duplicate_elements"         : ("geometry"                  , "geometry/duplicate_elements"           ),
    "geometry_proximity"         : ("geometry"                  , "geometry/geometry_proximity"           ),
    "geometry_to_instance"       : ("geometry"                  , "geometry/geometry_to_instance"         ),
    "join_geometry"              : ("geometry"                  , "geometry/join_geometry"                ),
    "merge_by_distance"          : ("geometry"                  , "geometry/merge_by_distance"            ),
    "raycast"                    : ("geometry"                  , "geometry/raycast"                      ),
    "separate_components"        : ("geometry"                  , "geometry/separate_components"          ),
    "separate_geometry"          : ("geometry"                  , "geometry/separate_geometry"            ),
    "transform"                  : ("geometry"                  , "geometry/transform"                    ),
    "set_id"                     : ("geometry"                  , "geometry/set_id"                       ),
    "set_position"               : ("geometry"                  , "geometry/set_position"                 ),

    "boolean"                    : ("input"                     , "input/boolean"                         ),
    "collection_info"            : ("input"                     , "input/collection_info"                 ),
    "color"                      : ("input"                     , "input/color"                           ),
    "integer"                    : ("input"                     , "input/integer"                         ),
    "is_viewport"                : ("input"                     , "input/is_viewport"                     ),
    "material"                   : ("input"                     , "input/material"                        ),
    "object_info"                : ("input"                     , "input/object_info"                     ),
    "scene_time"                 : ("input"                     , "input/scene_time"                      ),
    "string"                     : ("input"                     , "input/string"                          ),
    "value"                      : ("input"                     , "input/value"                           ),
    "vector"                     : ("input"                     , "input/vector"                          ),

    "input_index"                : ("input"                     , "input/input_index"                     ),
    "index"                      : ("input"                     , "input/input_index"                     ),

    "named_attribute"            : ("input"                     , "input/named_attribute"                 ),
    "normal"                     : ("input"                     , "input/normal"                          ),
    "position"                   : ("input"                     , "input/position"                        ),
    "radius"                     : ("input"                     , "input/radius"                          ),
    "id"                         : ("input"                     , "input/id"                              ),

    "instance_on_points"         : ("instances"                 , "instances/instance_on_points"          ),
    "instances_to_points"        : ("instances"                 , "instances/instances_to_points"         ),
    "rotate_instances"           : ("instances"                 , "instances/rotate_instances"            ),
    "scale_instances"            : ("instances"                 , "instances/scale_instances"             ),
    "translate_instances"        : ("instances"                 , "instances/translate_instances"         ),
    "realize_instances"          : ("instances"                 , "instances/realize_instances"           ),
    
    "replace_material"           : ("material"                  , "material/replace_material"             ),
    "material_index"             : ("material"                  , "material/material_index"               ),
    "material_selection"         : ("material"                  , "material/material_selection"           ),
    "set_material"               : ("material"                  , "material/set_material"                 ),
    "set_material_index"         : ("material"                  , "material/set_material_index"           ),

    "dual_mesh"                  : ("mesh"                      , "mesh/dual_mesh"                        ),
    "extrude_mesh"               : ("mesh"                      , "mesh/extrude_mesh"                     ),
    "flip_faces"                 : ("mesh"                      , "mesh/flip_faces"                       ),
    "mesh_boolean"               : ("mesh"                      , "mesh/mesh_boolean"                     ),
    "mesh_to_curve"              : ("mesh"                      , "mesh/mesh_to_curve"                    ),
    "mesh_to_points"             : ("mesh"                      , "mesh/mesh_to_points"                   ),
    "scale_elements"             : ("mesh"                      , "mesh/scale_elements"                   ),
    "split_edges"                : ("mesh"                      , "mesh/split_edges"                      ),
    "subdivide_mesh"             : ("mesh"                      , "mesh/subdivide_mesh"                   ),
    "subdivision_surface"        : ("mesh"                      , "mesh/subdivision_surface"              ),
    "triangulate"                : ("mesh"                      , "mesh/triangulate"                      ),
    "edge_angle"                 : ("mesh"                      , "mesh/edge_angle"                       ),
    "edge_neighbors"             : ("mesh"                      , "mesh/edge_neighbors"                   ),
    "edge_vertices"              : ("mesh"                      , "mesh/edge_vertices"                    ),
    "face_area"                  : ("mesh"                      , "mesh/face_area"                        ),
    "face_is_planar"             : ("mesh"                      , "mesh/face_is_planar"                   ),
    "face_neighbors"             : ("mesh"                      , "mesh/face_neighbors"                   ),
    "is_shade_smooth"            : ("mesh"                      , "mesh/is_shade_smooth"                  ),
    "mesh_island"                : ("mesh"                      , "mesh/mesh_island"                      ),
    "vertex_neighbors"           : ("mesh"                      , "mesh/vertex_neighbors"                 ),
    "set_shade_smooth"           : ("mesh"                      , "mesh/set_shade_smooth"                 ),

    "cone"                       : ("mesh_primitives"           , "mesh_primitives/cone"                  ),
    "cube"                       : ("mesh_primitives"           , "mesh_primitives/cube"                  ),
    "cylinder"                   : ("mesh_primitives"           , "mesh_primitives/cylinder"              ),
    "grid"                       : ("mesh_primitives"           , "mesh_primitives/grid"                  ),
    
    "icosphere"                  : ("mesh_primitives"           , "mesh_primitives/icosphere"             ),
    "ico_sphere"                 : ("mesh_primitives"           , "mesh_primitives/icosphere"             ),

    "mesh_circle"                : ("mesh_primitives"           , "mesh_primitives/mesh_circle"           ),
    "mesh_line"                  : ("mesh_primitives"           , "mesh_primitives/mesh_line"             ),
    "uv_sphere"                  : ("mesh_primitives"           , "mesh_primitives/uv_sphere"             ),

    "viewer"                     : ("output"                    , "output/viewer"                         ),

    "distribute_points_on_faces" : ("point"                     , "point/distribute_points_on_faces"      ),
    "points_to_vertices"         : ("point"                     , "point/points_to_vertices"              ),
    "points_to_volume"           : ("point"                     , "point/points_to_volume"                ),
    "set_point_radius"           : ("point"                     , "point/set_point_radius"                ),

    "join_strings"               : ("text"                      , "text/join_strings"                     ),
    "replace_string"             : ("text"                      , "text/replace_string"                   ),
    "slice_string"               : ("text"                      , "text/slice_string"                     ),
    "special_characters"         : ("text"                      , "text/special_characters"               ),
    "string_length"              : ("text"                      , "text/string_length"                    ),
    "string_to_curves"           : ("text"                      , "text/string_to_curves"                 ),
    "value_to_string"            : ("text"                      , "text/value_to_string"                  ),

    "brick"                      : ("texture"                   , "texture/brick"                         ),
    "brick_texture"              : ("texture"                   , "texture/brick"                         ),
    
    "checker"                    : ("texture"                   , "texture/checker"                       ),
    "checker_texture"            : ("texture"                   , "texture/checker"                       ),
    
    "gradient"                   : ("texture"                   , "texture/gradient"                      ),
    "gradient_texture"           : ("texture"                   , "texture/gradient"                      ),

    "image"                      : ("texture"                   , "texture/image"                         ),
    "image_texture"              : ("texture"                   , "texture/image"                         ),
    
    "magic"                      : ("texture"                   , "texture/magic"                         ),
    "magic_texture"              : ("texture"                   , "texture/magic"                         ),
    
    "musgrave"                   : ("texture"                   , "texture/musgrave"                      ),
    "musgrave_texture"           : ("texture"                   , "texture/musgrave"                      ),
    
    "noise"                      : ("texture"                   , "texture/noise"                         ),
    "noise_texture"              : ("texture"                   , "texture/noise"                         ),
    
    "voronoi"                    : ("texture"                   , "texture/voronoi"                       ),
    "voronoi_texture"            : ("texture"                   , "texture/voronoi"                       ),
    
    "wave"                       : ("texture"                   , "texture/wave"                          ),
    "wave_texture"               : ("texture"                   , "texture/wave"                          ),
    
    "white_noise"                : ("texture"                   , "texture/white_noise"                   ),
    "white_noise_texture"        : ("texture"                   , "texture/white_noise"                   ),
    
    "accumulate_field"           : ("utilities"                 , "utilities/accumulate_field"            ),
    "align_euler_to_vector"      : ("utilities"                 , "utilities/align_euler_to_vector"       ),
    "boolean_math"               : ("utilities"                 , "utilities/boolean_math"                ),
    "clamp"                      : ("utilities"                 , "utilities/clamp"                       ),
    "compare"                    : ("utilities"                 , "utilities/compare"                     ),
    "field_at_index"             : ("utilities"                 , "utilities/field_at_index"              ),
    "float_curve"                : ("utilities"                 , "utilities/float_curve"                 ),
    "float_to_integer"           : ("utilities"                 , "utilities/float_to_integer"            ),
    "map_range"                  : ("utilities"                 , "utilities/map_range"                   ),
    "math"                       : ("utilities"                 , "utilities/math"                        ),
    "random_value"               : ("utilities"                 , "utilities/random_value"                ),
    "rotate_euler"               : ("utilities"                 , "utilities/rotate_euler"                ),
    "switch"                     : ("utilities"                 , "utilities/switch"                      ),

    "combine_xyz"                : ("vector"                    , "vector/combine_xyz"                    ),
    "separate_xyz"               : ("vector"                    , "vector/separate_xyz"                   ),
    "vector_curves"              : ("vector"                    , "vector/vector_curves"                  ),
    "vector_math"                : ("vector"                    , "vector/vector_math"                    ),
    "vector_rotate"              : ("vector"                    , "vector/vector_rotate"                  ),

    "volume_to_mesh"             : ("volume"                    , "volume/volume_to_mesh"                 ),
    
    "group"                      : ("group"                     , "group"                                 ),
    
    
}



# ====================================================================================================
# Some nodes need to reorder the input sockets for more natural use
# Example : the input sockets node ShaderNodeMixRGB are order fac, color1, color2
#           by reordering color1, color2, fac allows to call color.mix(color_argument)
#           rather than color.mix(color2=color_argument)

INPUT_SOCKETS_ORDER = {
    'ShaderNodeMixRGB' : {'Fac': 2, 'Color1': 0, 'Color2': 1},
}

# ====================================================================================================
# Utility

def indent_set(depth=0):
    _indent_ = "    "
    _0_ = "\n" + _indent_ * max(0, 0 + depth)
    _1_ = "\n" + _indent_ * max(0, 1 + depth)
    _2_ = "\n" + _indent_ * max(0, 2 + depth)
    _3_ = "\n" + _indent_ * max(0, 3 + depth)
    _4_ = "\n" + _indent_ * max(0, 4 + depth)
    
    return _indent_, _0_, _1_, _2_, _3_, _4_

_indent_, _0_, _1_, _2_, _3_, _4_ = indent_set(0)


# ====================================================================================================
# Call argument
#
# Argument types:
#
# - SOCKET: The name of an input socket (wsocket must be not None).
#           If the socket is multi input, it must be the first argument:
#               - header: *name
#               - call  : *name
#           If the socket is not multi input
#               - header: name=None
#               - call  : name=name
#
# - PARAM : it is the name of a param (param can be None). It can be fixed or not
#           If fixed:
#               - header: ""
#               - call  : name=name
#           If not fixed
#               - header: name='VALUE'
#               - call  : name=name
#
# - CLS   : it is the cls argument
#         : - header : cls
#         : - call   : ""
#
# - OTHER : Not a socket nor a param
#         : - header : ""
#         : - call   : ""


class Argument:
    def __init__(self, arg_type, name, is_self=False):

        self.arg_type = arg_type
        self.name     = name
        self.is_self  = is_self
    
    def __init__OLD(self, name, value, quote_str_value=True, is_self=False, wsocket=None, param=None, is_fixed=False):
        
        self.name  = name
        
        if isinstance(value, str) and quote_str_value:
            self.value = f"'{value}'"
        else:
            self.value = value
        
        self.is_self  = is_self
        self.wsocket  = wsocket
        self.param    = param
        self.is_fixed = is_fixed
        
    @classmethod
    def Socket(cls, name, wsocket, is_self=False):
        arg         = cls('SOCKET', name, is_self=is_self)
        arg.wsocket = wsocket
        arg.is_self = is_self
        return arg
        
    @classmethod
    def Param(cls, name, value, quote_str_value=True, param=None, is_fixed=False):
        arg = cls('PARAM', name)
        if isinstance(value, str) and quote_str_value:
            arg.value = f"'{value}'"
        else:
            arg.value = value

        arg.param    = param
        arg.is_fixed = is_fixed
        return arg
        
    @classmethod
    def Cls(cls):
        return cls('CLS', "cls")
    
    @classmethod
    def Other(cls, header_str="", call_str="", **kwargs):
        arg = cls('OTHER', None)
        arg.header_str = header_str
        arg.call_str   = call_str
        for k, v in kwargs:
            setattr(arg, k, v)
        return arg
        
    @property
    def is_socket(self):
        return self.arg_type == 'SOCKET'
    
    @property
    def is_multi(self):
        if self.is_socket and not self.is_shared:
            return self.wsocket.is_multi_input
        else:
            return False
    
    @property
    def is_param(self):
        return self.arg_type == 'PARAM'

    @property
    def is_cls(self):
        return self.arg_type == 'CLS'
    
    @property
    def is_shared(self):
        return isinstance(self.wsocket, list)
    
    @property
    def scall_demo(self):
        
        if self.arg_type == 'CLS':
            return ""
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                return f"{self.name}_1, {self.name}_2, {self.name}_3"
            elif self.is_self:
                return ""
            else:
                return self.name
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return ""
            else:
                return self.name
            
        elif self.arg_type == 'OTHER':
            return self.header_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")
        
    
    @property
    def sheader(self):
        
        if self.arg_type == 'CLS':
            return "cls"
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name}"
                else:
                    return f"*{self.name}"
            else:
                if self.is_self:
                    return "self"
                else:
                    return f"{self.name}=None"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return ""
            else:
                return f"{self.name}={self.value}"
            
        elif self.arg_type == 'OTHER':
            return self.header_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

    @property
    def scall(self):

        if self.arg_type == 'CLS':
            return ""
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name}"
                else:
                    return f"*{self.name}"
            else:
                if self.is_self:
                    return f"{self.name}=self"
                else:
                    return f"{self.name}={self.name}"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return f"{self.name}={self.value}"
            else:
                return f"{self.name}={self.name}"
            
        elif self.arg_type == 'OTHER':
            return self.call_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

        
    @property
    def scomment(self):
        
        if self.arg_type == 'CLS':
            return ""
        
        if self.arg_type == 'OTHER':
            if self.header_str == "":
                return ""
            else:
                return self.header_str.replace('=', ':')
        
        s = f"{self.name} : "
        if self.is_socket:
            if self.is_multi:
                s += "*"
            s += self.wsocket.class_name
            if self.is_self:
                s += " (self)"
        else:
            if self.param is None:
                s += f"{self.value} ({type(self.value).__name__})"
            else:
                s += str(self.value)
                if self.param.is_enum and not self.is_fixed:
                    s += f" in {self.param.short_values}"
                    
        return s
    
    @property
    def splug(self):
        if not self.is_socket or self.is_shared:
            return None
        
        s = f"self.plug({self.wsocket.index}, "
        if self.is_self:
            s += "self"
            if self.is_multi:
                s += f" *{self.wsocket.uname}"
            return s + ")"
        else:
            if self.is_multi:
                s += "*"
            return s + f"{self.wsocket.uname})"
        
# ---------------------------------------------------------------------------
# A list of Arguments

class Arguments(list):
    
    def add(self, arg):
        if arg.is_self or arg.is_cls:
            self.insert(0, arg)
            
        elif arg.is_multi:
            if len(self) == 0:
                self.append(arg)
            elif self[0].is_self:
                self.insert(1, arg)
            else:
                self.insert(0, arg)
                
        else:
            self.append(arg)
    
    @property
    def scall_demo(self):
        s = ""
        for arg in self:
            sh = arg.scall_demo
            if sh != "":
                s += f", {sh}"
        if s != "":
            return s[2:]
        else:
            return s
        
    @property
    def sheader(self):
        s = ""
        for arg in self:
            sh = arg.sheader
            if sh != "":
                s += f", {sh}"
        if s != "":
            return s[2:]
        else:
            return s
        
    @property
    def scall(self):
        s = ""
        for arg in self:
            if arg.is_cls:
                continue
            
            if arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"
            
        for arg in self:
            if not arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"

        if s != "":
            return s[2:]
        else:
            return s

    # ---------------------------------------------------------------------------
    # Check the order of the sockets arguments
    
    def check_order(self, bl_idname):

        order = INPUT_SOCKETS_ORDER.get(bl_idname)
        if order is None:
            return
        reorder = [None] * len(order)
        for arg in self:
            if not arg.is_socket:
                continue
            
            name = arg.wsocket.bsocket.name
            if name in order:
                reorder[order[name]] = arg
        
        for arg in reorder:
            if arg is not None:
                self.remove(arg)
            
        for arg in reversed(reorder):
            if arg is not None:
                self.insert(0, arg)

    # ---------------------------------------------------------------------------
    # Generate the comments in a node call
    
    def documentation(self):
        
        sections = {"Sockets": [], "Parameters": [], "Fixed parameters": []}
        
        for arg in self:
            
            section = None
            if arg.arg_type == 'OTHER':
                if arg.header_str == "":
                    s = arg.call_str
                    section = sections["Fixed parameters"]
                else:
                    s = arg.header_str
                    section = sections[ "Parameters"]
                    
                if s == "":
                    continue
                
                section.append(s.replace("=", ":"))

            else:
                scomment = arg.scomment
                if scomment == "":
                    continue
            
                if arg.is_socket:
                    sections["Sockets"].append(scomment)
                elif arg.is_param:
                    if arg.is_fixed:
                        sections["Fixed parameters"].append(scomment)
                    else:
                        sections["Parameters"].append(scomment)
                        
        text = ""
        for section, lst in sections.items():
            if lst:
                lst.insert(0, f"## {section}")
                text += "\n    - ".join(lst)
                
        return text

# ====================================================================================================
# Socket wrapper

class WSocket:
    
    SOCKET_CLASSES = {
        'NodeSocketBool'        : ('Boolean',    '',             'BOOLEAN'), 

        'NodeSocketInt'         : ('Integer',    '',             'INT'), 
        'NodeSocketIntUnsigned' : ('Integer',    'Unsigned',     'INT'), 

        'NodeSocketFloat'       : ('Float',      '',             'FLOAT'), 
        'NodeSocketFloatFactor' : ('Float',      'Factor',       'FLOAT'),
        'NodeSocketFloatAngle'  : ('Float',      'Angle',        'FLOAT'), 
        'NodeSocketFloatDistance': ('Float',     'Distance',     'FLOAT'), 

        'NodeSocketVector'      : ('Vector',     '',             'FLOAT_VECTOR'), 
        'NodeSocketVectorEuler' : ('Vector',     'Rotation',     'FLOAT_VECTOR'),
        'NodeSocketVectorXYZ'   : ('Vector',     'xyz',          'FLOAT_VECTOR'), 
        'NodeSocketVectorTranslation' : ('Vector', 'Translation','FLOAT_VECTOR'), 

        'NodeSocketColor'       : ('Color',      '',             'FLOAT_COLOR'), 
        'NodeSocketString'      : ('String',     '',             'FLOAT_COLOR'), 

        'NodeSocketGeometry'    : ('Geometry',   '',              None), 

        'NodeSocketCollection'  : ('Collection', '',              None), 
        'NodeSocketImage'       : ('Image',      '',              None), 
        'NodeSocketMaterial'    : ('Material',   '',              None), 
        'NodeSocketObject'      : ('Object',     '',              None), 
        'NodeSocketTexture'     : ('Texture',    '',              None), 
        'NodeSocketVirtual'     : ('Virtual',    '',              None),
        }
        
    DATA_TYPES = {
        'INT'         : 'Integer',
        'RGBA'        : 'Color',
        'FLOAT_VECTOR': 'Vector',
        'FLOAT_COLOR' : 'Color',
    }
    
    DOMAIN_DATA_TYPES = {
        'Float'     : 'FLOAT',
        'Integer'   : 'INT',
        'Vector'    : 'FLOAT_VECTOR',
        'Color'     : 'FLOAT_COLOR',
        'Boolean'   : 'BOOLEAN'
    }

    def __init__(self, bsocket, index):
        self.bsocket    = bsocket
        self.index      = index
        self.uname      = self.name
        self.class_name = WSocket.SOCKET_CLASSES[self.bsocket.bl_idname][0]
        self.domain_data_type = WSocket.DOMAIN_DATA_TYPES.get(self.class_name)
        if self.class_name == 'Geometry':
            if self.name.lower() in ['mesh', 'points', 'instances', 'volume', 'spline', 'curve']:
                self.class_name = self.name.capitalize()
                
    def __repr__(self):
        return f"<{self.uname} ({self.class_name})>"
    
    @staticmethod
    def domain_data_type(bl_idname):
        return WSocket.SOCKET_CLASSES[bl_idname][2]
    
    @property
    def bl_idname(self):
        return self.bsocket.bl_idname
        
    @property
    def enabled(self):
        return self.bsocket.enabled
    
    @property
    def name(self):
        s = self.bsocket.name.lower().replace(' ', '_')
        if s == 'id':
            return 'ID'
        else:
            return s
    
    @property
    def is_multi_input(self):
        return self.bsocket.is_multi_input
    
    @property
    def is_output(self):
        return self.bsocket.is_output
    
# ---------------------------------------------------------------------------
# A list of WSockets

class WSockets(list):
    
    def __init__(self, bsockets):
        super().__init__()
        self.bsockets = bsockets
        for index, bsocket in enumerate(self.bsockets):
            if bsocket.bl_idname != 'NodeSocketVirtual':
                self.append(WSocket(bsocket, index))
            
        # ---------------------------------------------------------------------------
        # Sockets can have the same name. Two cases:
        # 1. HOMNYMS: They are of the same class
        #    Only for input sockets. It correspond to parameters of same types,
        #    for instance for an operation
        # 2. SHARED: They are not of the same class
        #    Only one of them can be enabled
        
        names = {}
        for wsock in self:
            if wsock.name in names:
                names[wsock.name].append(wsock)
            else:
                names[wsock.name] = [wsock]
                
        # ----- unames
        # - key   : the unique name shared between several sockets
        # - value : the list of wsockets it is shared among
                
        self.unames = {}
        for name, wsocks in names.items():
            if len(wsocks) == 1:
                self.unames[name] = wsocks[0]
            else:
                class_name    = wsocks[0].class_name
                display_shape = wsocks[0].bsocket.display_shape
                distinction   = 'HOMONYMS'
                
                for wsock in wsocks:
                    if (wsock.class_name != class_name) or (wsock.bsocket.display_shape != display_shape):
                        self.unames[wsock.name] = wsocks
                        distinction = 'SHARED'
                        break
                    
                if distinction == 'HOMONYMS':
                    if wsocks[0].is_output:
                        raise RuntimeError("Big mistake !!!")
                    for i, wsock in enumerate(wsocks):
                        wsock.uname = f"{name}{i}"
                        self.unames[wsock.uname] = wsock
                        
        # ----- unames indices
        # - key     : the unique name
        # - value   : a dictionay giving the socket index from the driving
        #             parameter value
        # Initialized by the owner node by making vary the driving parameter
        # and by calling the method update_unames_indices
        #
        # Example:
        # unames_indices = {'from_value': {'FLOAT': 0, 'VECTOR': 2}, 'to_value': {'FLOAT': 1, 'VECTOR' : 3}}

        self.unames_indices = {}
        for uname in self.unames:
            self.unames_indices[uname] = {}
            
    # ----------------------------------------------------------------------------------------------------
    # The sockets which are shared according a driving parameter                 
                        
    @property
    def shared_sockets(self):
        sel = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                sel[uname] = wsocks
        return sel
    
    # ----------------------------------------------------------------------------------------------------
    # The node makes vary the driving parameter. At each change, it calls the following
    # method to update the unames_indices dictionary
        
    def update_unames_indices(self, param_value):
        for uname, wsocks in self.shared_sockets.items():
            for wsock in wsocks:
                if wsock.enabled:
                    if self.unames_indices[uname].get(param_value) is not None:
                        raise RuntimeError("Unconsistant, really !")
                    self.unames_indices[uname][param_value] = wsock.index
    

    # ----------------------------------------------------------------------------------------------------
    # Get the currently enabled sockets
    
    def enabled_sockets(self):
        wsockets = []
        for wsock in self:
            if wsock.enabled:
                wsockets.append(wsock)
        return wsockets
    
    # ====================================================================================================
    # Output sockets indices
    # Used to build the output_sockets property of the generated class
    
    def get_socket_indices(self, fixed):
        inds = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                index = self.unames[uname][fixed[self.driving_param]]
            else:
                index = wsocks.index
            inds[uname] = index
        return inds
    
# ====================================================================================================
# A parameter wrapper

class Parameter:
    def __init__(self, wnode, name):
        self.wnode   = wnode
        self.name    = name
        self.uname   = name

        self.is_enum = False
        self.default = self.value
        self.param_type = type(self.default).__name__ 
        
        if isinstance(self.default, bpy.types.bpy_struct):
            self.default = None
        elif isinstance(self.default, mathutils.Vector):
            self.default = list(self.default)
        if isinstance(self.default, str):
            try:
                setattr(self.wnode.bnode, self.name, 'ERROR')
                #self.value = 'ERROR'
            except TypeError as e:
                msg = str(e)
                i = msg.find('enum "ERROR" not found in')
                self.is_enum = i > 0
                if self.is_enum:
                    self.values = eval(msg[i+26:])
                    
    @property
    def sdefault(self):
        if isinstance(self.default, str):
            return f"'{self.default}'"
        else:
            return self.default
        
    @property
    def value(self):
        return getattr(self.wnode.bnode, self.name)
    
    @value.setter
    def value(self, v):
        try:
            setattr(self.wnode.bnode, self.name, v)
        except:
            pass
            #print(f"CAUTION: error when setting parameter {self.name} with value '{v}'")
        
    def reset(self):
        if self.default is not None:
            self.value = self.default
            
    @property
    def short_values(self):
        s = ""
        ok_pass = True
        for i, value in enumerate(self.values):
            if (len(s) < 30) or (i >= len(self.values)-3):
                s += f", {value}"
            else:
                if ok_pass:
                    s += ',... '
                    ok_pass = False
        return f"[{s[2:]}]"
        
            
# ====================================================================================================
# A node wrapper

class WNode:
    
    WNODES = {}
    
    STD_ATTRS = [
       '__doc__', '__module__', '__slots__', 'bl_description', 'bl_height_default', 'bl_height_max',
       'bl_height_min', 'bl_icon', 'bl_idname', 'bl_label', 'bl_rna', 'bl_static_type',
       'bl_width_default', 'bl_width_max', 'bl_width_min', 'color', 'dimensions', 'draw_buttons',
       'draw_buttons_ext', 'height', 'hide', 'input_template', 'inputs', 'internal_links',
       'is_registered_node_type', 'label', 'location', 'mute', 'name', 'output_template', 'outputs',
       'parent', 'poll', 'poll_instance', 'rna_type', 'select', 'show_options', 'show_preview',
       'show_texture', 'socket_value_update', 'type', 'update', 'use_clamp', 'use_custom_color',
       'width', 'width_hidden']
    
    def __init__(self, bnode):
        
        #print("NODE bl_idname", bnode.bl_idname)
        
        WNode.WNODES[bnode.bl_idname] = self
        
        self.bnode   = bnode
        self.inputs  = WSockets(self.bnode.inputs)
        self.outputs = WSockets(self.bnode.outputs)
        
        self.parameters = {}
        for param_name in dir(self.bnode):
            if not param_name in WNode.STD_ATTRS:
                param = Parameter(self, param_name)
                if param.default is None:
                    continue
                    
                self.parameters[param_name] = param
                if param_name in self.outputs.unames:
                    self.parameters[param_name].uname = param_name + '_'
                    
        # ----- shared sockets : a unique name is shared between several sockets
                    
        self.has_shared_sockets = bool(self.inputs.shared_sockets) or bool(self.outputs.shared_sockets)
        
        if self.has_shared_sockets:
            self.driving_param = 'input_type' if hasattr(self.bnode, 'input_type') else 'data_type'
            
            param = self.parameters[self.driving_param]
            for value in param.values:
                param.value = value
                self.inputs.update_unames_indices(value)
                self.outputs.update_unames_indices(value)
                
        # ----- Data sockets calling this node
        
        self.data_sockets = {}
                

    def __str__(self):
        return f"[{self.node_name}]"
    
    def register_socket(self, class_name, name, family):
        lst = self.data_sockets.get(class_name)
        if lst is None:
            self.data_sockets[class_name] = [(name, family)]
        else:
            lst.append((name, family))
        
        
    @property
    def bl_idname(self):
        return self.bnode.bl_idname
    
    @property
    def node_name(self):
        
        # ----- Some hacks
        
        if self.bnode.name == "ColorRamp":
            return "ColorRamp"
        
        # ----- Standard
        
        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            if word.lower() == 'id':
                s += 'ID'
            else:
                s += word.capitalize()
        return s
        #return "Node" + s
    
    @property
    def function_name(self):

        # ----- Some hacks
        
        if self.bnode.name == "ColorRamp":
            return "color_ramp"
        
        # ----- Standard

        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            w = word.lower()
            if w == 'id':
                w = 'ID'
            if w == '_':
                s += '_'
            else:
                if s != "":
                    s += '_'
                s += w
        return s
    
    @property
    def blender_ref_name(self):
        return self.bnode.name.lower().replace(' ', '_')
    
    @property
    def blender_ref_menu(self):
        return NODES_MENU[self.blender_ref_name][0]
    
    # ---------------------------------------------------------------------------
    # Blender reference

    @property
    def blender_python_ref(self):
        return f"https://docs.blender.org/api/current/bpy.types.{self.bl_idname}.html"
    
    @property
    def blender_ref(self):
        return f"https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/{NODES_MENU[self.blender_ref_name][1]}.html"
    
    
    # ---------------------------------------------------------------------------
    # Set parameters

    def reset_params(self):
        for param in self.parameters.values():
            param.reset()

    def set_params(self, param_values={}):
        for name, param in self.parameters.items():
            if name in param_values:
                param.value = param_values[name]
            else:
                param.reset()
                
    # ----------------------------------------------------------------------------------------------------
    # Non driving parameters
    
    def non_driving_params(self):
        params = {}
        for name, param in self.parameters.items():
            if name == self.driving_param:
                continue
            params[name] = Parameter(self, name)
        return params
    
    # ----------------------------------------------------------------------------------------------------
    # Node arguments
    
    def get_node_arguments(self):

        args = Arguments()
        for uname, wsock in self.inputs.unames.items():
            args.add(Argument.Socket(uname, wsocket=wsock))
            
        for name, param in self.parameters.items():
            args.append(Argument.Param(name, param.default, param=param))
            
        args.check_order(self.bl_idname)
            
        return args
    
    # ====================================================================================================
    # Enabled sockets with the fixed parameters
    # makes the free parameters vary to check which sockets to use
    
    def sockets_unames(self, wsockets, fixed={}):
    
        self.set_params(fixed)
        
        ens = [wsock.enabled for wsock in wsockets]
        for name, param in self.parameters.items():
            if name in fixed:
                continue
            if not param.is_enum:
                continue
            
            # ----- Reload the enum values to explore the possibilities
            
            new_param = Parameter(self, name)
            for value in new_param.values:
                param.value = value
                for i, wsock in enumerate(wsockets):
                    if wsock.enabled:
                        ens[i] = True
            new_param.value = new_param.default
        
        # ----- Let's keep only the outputs which can be enabled
        
        self.set_params(fixed)

        fixed_shared = True
        if self.has_shared_sockets:
            fixed_shared = self.driving_param in fixed
                
        unames = {}
        for i, wsock in enumerate(wsockets):
            if ens[i] and (wsock.uname not in unames):
                if fixed_shared or wsock.uname not in wsockets.shared_sockets:
                    unames[wsock.uname] = wsock.class_name
                else:
                    unames[wsock.uname] = f"{self.driving_param} dependant"
                    
        return unames

    # ----------------------------------------------------------------------------------------------------
    # Argument sockets

    def input_unames(self, fixed={}):
        return self.sockets_unames(self.inputs, fixed=fixed)
    
    # ----------------------------------------------------------------------------------------------------
    # Returned sockets
    
    def output_unames(self, fixed={}):
        return self.sockets_unames(self.outputs, fixed=fixed)
    
    # ====================================================================================================
    # Formatting utility
    
    @staticmethod
    def format_list(values, width=100, first_width=None):
        
        if not values:
            return "[]"
        
        is_str = isinstance(values[0], str)
        if first_width is None:
            first_width = width
        w = first_width
        s = "["
        sep = ""
        for i, value in enumerate(values):
            if is_str:
                s += f"{sep} '{value}'"
            else:
                s += "{sep} {str(value)}"
            if len(s) >= w:
                if i == len(values)-1:
                    yield s + "]"
                else:
                    yield s + ","
                s   = ""
                sep = ""
                w   = width
                
        if s != "":
            yield s + "]"
            
    # ====================================================================================================
    # Build the documentation
    
    def documentation(self):

        args = self.get_node_arguments()
        
        # ----- Source code demo
        
        s = args.sheader
        scall = f"node = nodes.{self.node_name}({s}"
        if s != "":
            scall += ", "
        scall += "label=None, node_color=None)"
        
        section = Section(None, f"Node {self.node_name}")
        section.id = self.node_name
        
        section.set_text(f"""
        > Geometry node name: [{self.bnode.name}]({self.blender_ref})<br>
        > Blender type: [{self.bnode.name}]({self.blender_python_ref})
        
        <sub>go to [index](ref:index)</sub>
        
        Initialization
        --------------
        
        ```python
        from geonodes import nodes
        {scall}
        ```
        
        """)
        
        # ----- Arguments
        
        arg_section = Section(section, "Arguments")
    
        if self.inputs:
            
            lst = [""]
            for uname, wsock in self.inputs.unames.items():
                
                if isinstance(wsock, list):
                    sval = f"{self.driving_param} dependant"
                elif wsock.is_multi_input:
                    sval = f"*{wsock.class_name}"
                else:
                    sval = f"{wsock.class_name}"
                
                lst.append(f"{uname} : {sval}")
                
            new_section = Section(arg_section, "Input sockets")
            new_section.set_text("\n- ".join(lst))
            
        if self.parameters:
            
            lst = [""]
            for name, param in self.parameters.items():
                
                stype = param.param_type
                if stype == 'str':
                    stype = f"{stype} (default = '{param.default}')"
                else:
                    stype = f"{stype} (default = {param.default})"
                
                if param.is_enum:
                    stype += f" in {param.values}"
                    
                lst.append(f"{name} : {stype}")
                
            new_section = Section(arg_section, "Parameters")
            new_section.set_text("\n- ".join(lst))
            
        new_section = Section(arg_section, "Node label")
        new_section.set_text(
            f"- label : Geometry node display label (default=None)\n" +
            f"- node_color : Geometry node color (default=None)")
            
        
        # ----- Data type dependant sockets
                    
        if self.has_shared_sockets:
            
            new_section = Section(section, "Data type dependant sockets")
            new_section.set_text(f"""
                                 
            - Driving parameter : {self.driving_param} in {self.parameters[self.driving_param].values}
            - Input sockets  : {list(self.inputs.shared_sockets.keys())}
            - Output sockets : {list(self.outputs.shared_sockets.keys())}   
                              
            """)

        # ----- Output sockets
    
        if self.outputs:
            lst = [""]
            for uname, wsock in self.outputs.unames.items():
                
                if isinstance(wsock, list):
                    sval = f"{self.driving_param} dependant"
                else:
                    sval = wsock.class_name
                    if wsock.is_multi_input:
                        sval += "(multi input)"
                
                lst.append(f"{uname} : {sval}")
                
            new_section = Section(section, "Output sockets")
            new_section.set_text("\n- ".join(lst))
                
        # ----- Data classes
        
        if self.data_sockets:
            
            lst = [""]
            for class_name in sorted(self.data_sockets):
                refs = sorted(self.data_sockets[class_name], key=lambda nf: nf[0])
                for meth_name, family in refs:
                    lst.append(f"[{class_name}](id:{class_name}).[{meth_name}](id:{class_name}#{meth_name}) : {family}")
                    
            new_section = Section(section, "Data sockets")
            slst = "\n- ".join(lst)
            new_section.set_text(f"> Data socket classes implementing this node.\n\n{slst}\n")
        
        return section
    
    # ====================================================================================================
    # Generate the node class
    
    def gen_node_class(self, wrap_parameters=True):
        
        args = self.get_node_arguments()
        
        # ---------------------------------------------------------------------------
        # Class header
        #
        # class NodeMath(Node):
        
        yield _0_ + f"class {self.node_name}(Node):\n"
    
        # ---------------------------------------------------------------------------
        # Class comment
        
        section = self.documentation()
        self.node_doc = section
        first = True
        for line in section.gen_text(False):
            if first:
                yield _1_ + '"""' + line
                first = False
            else:
                yield _1_ + line
                
        yield _1_ + '"""' + "\n"
    
        # ---------------------------------------------------------------------------
        # Constructor __init__
        #
        # def __init__(self, input sockets, param sockets, label):
    
        yield _1_ + "def __init__(self"
        s = args.sheader
        if s != "":
            yield ", " + s
        yield ", label=None, node_color=None):\n"
    
        # ---------------------------------------------------------------------------
        # Call of super
        #
        # super().__init__(bl_idname, name, label)
        
        yield _2_ + f"super().__init__('{self.bl_idname}', name='{self.bnode.name}', label=label, node_color=node_color)\n"

        # ---------------------------------------------------------------------------
        # Parameters
        #
        # self.bnode.data_type = data_type
        
        yield_comment = True
        for name, param in self.parameters.items():
            if yield_comment:
                if self.has_shared_sockets:
                    yield _2_ + "# Node parameters to configure the sockets enablement\n"
                else:
                    yield _2_ + "# Node parameters\n"
                yield_comment = False
            
            yield _2_ + f"self.bnode.{param.name:15s} = {name}"
        
        if not yield_comment:
            yield "\n"
            
        # ---------------------------------------------------------------------------
        # Input and output socket unique names towards indices
        # Node insockets and outsockets provide the index (or list of indices) for each socket uname
        # - outsockets is used by getattr to get the output sockets by their name
        # - insockets is used by setattr to plug in input sockets
        #self.insockets  = {}
        #self.outsockets = {}
        
        yield _2_ + "# Input and output sockets names (for use in __getattr__ and __setattr__)\n"
        
        yield _2_ + "self.insockets = {"
        for uname, wsocks in self.inputs.unames.items():
            if isinstance(wsocks, list):
                yield f"'{uname}' : {[ws.index for ws in wsocks]}, "
            else:
                yield f"'{uname}' : {wsocks.index}, "
        yield "}"
        
        
        yield _2_ + "self.outsockets = {"
        for uname, wsocks in self.outputs.unames.items():
            if isinstance(wsocks, list):
                yield f"'{uname}' : {[ws.index for ws in wsocks]}, "
            else:
                yield f"'{uname}' : {wsocks.index}, "
        yield "}\n"
        
            
    
        # ---------------------------------------------------------------------------
        # Shared Input sockets
        # if the node has shared sockets, two loops:
        # - loop on the possible values of the driving parameter
        # - loop on the shared input sockets
        #
        # inputs.shared_sockets: {socket.uname: [wsockets...]}
        # inputs.unames_indices: {socket.uname: {param value: index}}
        #
        # if data_type == 'FLOAT':
        #     self.plug(0, value0)
        #     self.plug(2, value1)
        # elif data_type == 'VECTOR':
        #     self.plug(1, value0)
        #     self.plug(3, value1)
        
        """
        
        yield_comment = True
        if self.has_shared_sockets:
            param = self.parameters[self.driving_param]
            sif = "if"
            for index, value in enumerate(param.values):
                yield_if = True
                for uname, valinds in self.inputs.unames_indices.items():
                    idx = valinds.get(value)
                    if idx is not None:
                        
                        if yield_comment:
                            yield _2_ + "# Input sockets\n"
                            yield_comment = False
                        
                        if yield_if:
                            yield _2_ + f"{sif} {self.driving_param} == '{value}':"
                            sif = "elif"
                            yield_if = False
                        yield _3_ + f"self.plug({idx}, {uname})"
            yield "\n"

        # ---------------------------------------------------------------------------
        # Other input sockets
        #
        # self.plug(4, factor)
        
        for arg in args:
            if not arg.is_socket or arg.is_shared:
                continue
            
            if yield_comment:
                yield _2_ + "# Input sockets\n"
                yield_comment = False
            
            yield _2_ + arg.splug

        if not yield_comment:
            yield "\n"
        
        # ---------------------------------------------------------------------------
        # Shared outputs sockets
        #
        # See shared input sockets
        #
        # if data_type == 'FLOAT':
        #     self.value = self.Float(self.bnode.outputs[0])
        # elif data_type == 'VECTOR':
        #     self.value = self.Vector(self.bnode.outputs[1])
        
        yield_comment = True
        if self.has_shared_sockets:
            param = self.parameters[self.driving_param]
            sif = "if"
            for index, value in enumerate(param.values):
                yield_if = True
                for uname, valinds in self.outputs.unames_indices.items():
                    idx = valinds.get(value)
                    if idx is not None:
                        
                        if yield_comment:
                            yield _2_ + "# Output sockets\n"
                            yield_comment = False
                        
                        if yield_if:
                            yield _2_ + f"{sif} {self.driving_param} == '{value}':"
                            sif = "elif"
                            yield_if = False
                        yield _3_ + f"self.{uname:15s} = self.{self.outputs[idx].class_name}(self.bnode.outputs[{idx}])"

            yield "\n"
            
        # ---------------------------------------------------------------------------
        # Other output sockets
        #
        # self.fac = self.Float(self.bnode.outputs[2])
        
        socks = []
        for wsocket in self.outputs:
            
            if not wsocket.uname in socks:
                socks.append(wsocket.uname)
                
            if wsocket.uname in self.outputs.shared_sockets:
                continue
            
            if yield_comment:
                yield _2_ + "# Output sockets\n"
                yield_comment = False
            
            idx = wsocket.index
            yield _2_ + f"self.{wsocket.uname:15s} = self.{self.outputs[idx].class_name}(self.bnode.outputs[{idx}])"
            
        yield _2_ + "self.output_sockets  = {"
        sep = ""
        for sock in socks:
            yield f"{sep}'{sock}': self.{sock}"
            sep = ", "
        yield "}"

        yield "\n"
        
        """

        # ---------------------------------------------------------------------------
        # Now that the insockets are declared, we can set the input sockets
        
        yield_comment = True
        for uname, wsocks in self.inputs.unames.items():
            if yield_comment:
                yield _2_ + "# Input sockets plugging\n"
                yield_comment = False
                
            # Multi input hack
            if not isinstance(wsocks, list):
                if wsocks.is_multi_input:
                    yield _2_ + f"self.plug({wsocks.index}, *{uname})"
                    continue
            
            yield _2_ + f"self.{uname:15s} = {uname}"

        if not yield_comment:
            yield "\n"
        
        
        
        
        
    
        # ---------------------------------------------------------------------------
        # Wrap the parameters
        
        if wrap_parameters:
            for name, param in self.parameters.items():
                yield _1_ +  "@property"
                yield _1_ + f"def {param.uname}(self):"
                yield _2_ + f"return self.bnode.{name}\n"
            
                yield _1_ + f"@{param.uname}.setter"
                yield _1_ + f"def {param.uname}(self, value):"
                yield _2_ + f"self.bnode.{name} = value\n"

        
# ====================================================================================================
# Create a tree with all the possible nodes

class BNodes(dict):
    
    def __init__(self):
        print("Collecting the available geometry nodes...")        
        super().__init__()

        btree_nodes = bpy.data.node_groups["Geometry Nodes"].nodes
        btree_nodes.clear()

        for tp in dir(bpy.types):
            if tp.find('Legacy') < 0:
                try:
                    bnode = btree_nodes.new(tp)
                except:
                    continue
                self[tp] = bnode

# ====================================================================================================
# Generate the files

#generated_nodes = []
#generated_sockets = []

# ----------------------------------------------------------------------------------------------------
# Package documentation

package_doc = Doc()
package_doc.md_folder = "docs"
package_doc.references['index'] = "/docs/index.md"

sockets_doc = Section(package_doc, "Data sockets")
sockets_doc.md_folder = "sockets"

nodes_doc   = Section(package_doc, "Nodes")
nodes_doc.md_folder = "nodes"

core_doc   = Section(package_doc, "Core")
core_doc.md_folder = ""


# ----------------------------------------------------------------------------------------------------
# Generate the classes
# 
# When a classes is created, it update the nodes it uses
                
def create_data_sockets(fpath):
    
    # ----- sockets files

    gsock.GEN_NODES = []
    class_gens = []
    
    nodes_md = {}
    
    # ---------------------------------------------------------------------------
    # Loop on the data sockets generators

    for i, dgen in enumerate(gsock.DATA_CLASSES):
        
        class_gen = dgen(WNode.WNODES)
        class_gens.append(class_gen)
        
        with open(fpath + f"sockets/{class_gen.class_name.lower()}.py", 'w') as f:

            for line in class_gen.gen_class():
                f.write(line)
                
            f.write("\n\n")
            
        class_gen.register_nodes()
        
        # ----------------------------------------------------------------------------------------------------
        # Add the class documentation to the global doc
        
        sockets_doc.add_section(class_gen.class_doc)

        # ----- For further indexing
                
        #generated_sockets.append(class_gen.class_name)


# ----------------------------------------------------------------------------------------------------
# Creat all the nodes in 

def create_nodes(fpath, BNODES):
    
    fname = fpath + "nodes/nodes.py"
    
    with open(fname, 'w') as f:
        
        QUOTES = '"""'
        
        f.write(f"""#!/usr/bin/env python3
# -*- coding: utf-8 -*-

{QUOTES}
Created on {date.today()}
@author: Generated from generator module
Blender version: {bpy.app.version_string}
{QUOTES}

from geonodes.core.node import Node

""")

        creation = []
        for bnode in BNODES.values():
            
            # ----------------------------------------------------------------------------------------------------
            # Load the node
            
            wn = WNode.WNODES[bnode.bl_idname]
            
            # ----- Some exclusion
            
            if wn.bl_idname in ['NodeReroute', 'NodeGroupInput', 'NodeGroupOutput', 'GeometryNodeViewer', 'NodeFrame']:
                continue
            
            # ----- Write the node
            
            f.write(f"\n# {'-'*100}\n")
            f.write(f"# Node {wn.node_name} for {wn.bl_idname}\n")

            for line in wn.gen_node_class():
                f.write(line)
                
            # ----- The documentation
            
            wn.node_doc.md_file = f"{wn.node_name}.md"
            nodes_doc.add_section(wn.node_doc)
                    
            # ----- For creation by bl_idname
            
            creation.append(f"'{wn.bl_idname}': {wn.node_name}") 
            
        # ----- A function to create a node from the bl_idname
        
        f.write(f"# {'-'*80}\n")
        f.write("# Create node from its bl_idname\n\n")
        
        f.write( "def create_node(bl_idname, *args, **kwargs):\n")
        sdict = ",\n    ".join(creation)
        O = "{"
        C = "}"
        f.write(f"    nodes = {O}{sdict}{C}\n")
        f.write( "    return nodes[bl_idname](*args, **kwargs)\n\n")
        
        
        
        
                    
# ====================================================================================================
# Generate the nodes module
                
def create_geonodes(fpath):
    
    print("-"*80)
    print("Generating nodes and sockets python from Blender geometry nodes")
    print(f"Blender version: {bpy.app.version_string}")
    print("")
                
    # ----- Create all the blender nodes
    
    BNODES = BNodes()

    # ----- Create all the wrappers

    for bnode in BNODES.values():
        WNode(bnode)
        
    # ---------------------------------------------------------------------------
    # The field nodes are implemented in domains.py
    # We must load the documentation from the file to enrich the
    # references to the nodes
    
    # ----- Parse domains.py
    
    FIELDS = set()
    
    parsed_domains = Parser.FromFile(fpath + "core/domains.py").documentation()
    for class_name, cdoc in parsed_domains.items():
        for name, fdoc in cdoc.funcs.items():
        
            def repl(m):
                blid = m.group(2)
                FIELDS.add(blid)
                wn = WNode.WNODES[blid]
                
                wn.register_socket(class_name, name, 'Fields')
                
                lines = [
                    f" > Field [{wn.node_name}](/docs/nodes/{wn.node_name}.md)",
                     "",
                    f"Blender menu : **{NODES_MENU[wn.blender_ref_name][1]}**<br>",
                    f"<sub>go to [top](#class-{class_name.lower().replace(' ', '-')}) [index](ref:index)</sub>",
                    ]
                return "\n".join(lines)
            
            fdoc.comment = re.sub(r"(<\s*field\s+([^>]+)>)", repl, fdoc.comment)
    
    # ---------------------------------------------------------------------------
    # data sockets classes
    
    print("Creating data sockets...")
    
    create_data_sockets(fpath)

    # ---------------------------------------------------------------------------
    # nodes.py

    print("Creating geometry nodes from Blender...")

    create_nodes(fpath, BNODES)

    # ---------------------------------------------------------------------------
    # Documentation

    print("Documentation...")
    
    # ----- Parse node.py
    
    node_doc = Parser.FromFile(fpath + "core/node.py").documentation()
    
    for name in ["DataSocket", "Tree", "Node"]:
        section = Section.FromParserDoc(parent=core_doc, prefix = "Class", pdoc=node_doc[name])
        section.id = name
        section.md_file = f"{name}.md"
    
    for name in ["CustomGroup", "Group", "GroupInput", "GroupOutput", "Viewer", "Frame", "SceneTime"]:
        section = Section.FromParserDoc(parent=nodes_doc, prefix = "Node", pdoc=node_doc[name])
        section.id = name
        section.md_file = f"{name}.md"

    # ----- Parse datasockets.py
    
    ds_doc = Parser.FromFile(fpath + "core/datasockets.py").documentation()
    
    for section in sockets_doc:
        
        fname = fpath + section.file_link
        with open(fname, 'w') as f:
            for line in section.gen_text(True):
                f.write(line + "\n")

    # ----- Parse domains.py
        
    for name in ["Domain", "PointDomain", "EdgeDomain", "FaceDomain", "CornerDomain", "CurveDomain"]:
        section = Section.FromParserDoc(parent=core_doc, prefix = "Class", pdoc=parsed_domains[name])
        section.id = name
        section.md_file = f"{name}.md"
        
    # ----- Core
    # Core documentation enrich the list of nodes references

    for section in core_doc:
        text = "\n".join(section.gen_text(True))
        text = re.sub(r"(<\s*field\s+([^>]+)>)", repl, text)
        
        fname = fpath + section.file_link
        with open(fname, 'w') as f:
            f.write(text)
                
    # ----- Nodes

    print("Nodes documentation...")

    for section in nodes_doc:
        
        fname = fpath + section.file_link
        with open(fname, 'w') as f:
            for line in section.gen_text(True):
                f.write(line + "\n")

                
    # ----- Index

    print("Index...")
    
    fname = fpath + f"docs/index.md"
    with open(fname, 'w') as f:
        f.write("\n# Index\n\n")
        
        for section in package_doc.get_sections():
            f.write(f"\n## {section.title}\n\n")
            
            for line in section.gen_toc(depth=1, sort=True, classify=None, markdown=True):
                f.write(line + "\n")
                
    # ----- Implemented nodes
    
    print("Done\n")
    
    print("Nodes not implemented as socket methods:")
    count = 0
    for bnode in BNODES.values():
        if (bnode.bl_idname not in gsock.DataClass.GENS) and (bnode.bl_idname not in FIELDS):
            print(f"    {bnode.bl_idname:40s}: '{bnode.name}'")
            count += 1
            
    if count == 0:
        print("   all (ok)")
    else:
        print(f"\n   NOTE: Check if the {count} node{'s' if count > 1 else ''} should be implemented as methods.\n")
        
    print('Generation completed')
    print()
    print('-'*80)
    print("NOTE: if new nodes are created, don't forget to run node_sizes():")
    print("Node dimensions are intizalized to zero. To update the property correctly, go")
    print("in the geometry nodes editor and then back to the script editor.")
    print("Lauch generator.node_sizes() WITHOUT LAUNCHING create_geonodes AGAIN!")
    print("... hope it works.")
    
    
    return
    
    # ---------------------------------------------------------------------------
    # Index
    
    doc = gd.Section("Index", level=0)

    section = doc.get_subsection("Data sockets")
    
    lst = gd.List()
    for class_name in generated_sockets:
        lst.add_item(gd.Text(gd.Link(class_name, f"sockets/{class_name}.md")))

    section.append(lst)
        
    
    section = doc.get_subsection("Nodes")

    lst = gd.List()
    for node_name in generated_nodes:
        lst.add_item(gd.Text(gd.Link(node_name, f"nodes/{node_name}.md")))

    section.append(lst)
    
    
    fname = fpath + f"docs/index.md"
    with open(fname, 'w') as f:
        for line in doc.gen_md():
            f.write(line + "\n")
            
    # ---------------------------------------------------------------------------
    # Done
    
    print("geondes files generated")
    
# ====================================================================================================
# Generate the nodes module
                    
def node_sizes():
    print()
    print("Node sizes (to include in module 'arrange.py'")
    print("To collect the proper size calls this function once they have been generated with create_geonodes")
    print()
    
    
    btree_nodes = bpy.data.node_groups["Geometry Nodes"].nodes
    for bnode in btree_nodes:
        s = f"'{bnode.bl_idname}'"
        pat = r"\([^\)]*\)"
        print(f"    {s:42s}: {re.findall(pat, str(bnode.dimensions))[0]},")
        
    print()
        

    
    

    
