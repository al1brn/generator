#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun May 29 12:31:31 2022

@author: alain

Generate geonodes Blender addon

====================================================================================================
Description

The geonodes implements two layers:
    - Nodes layer
        One class per geometry nodes, for instance AlignEulerToVector wraps the node FunctionNodeAlignEulerToVector
        The Node class initialization creates the geometry nodes
    - Sockets layer
        One class per data type:
            Basis data: Boolean, Integer, Float, Vector, Color, String
            Geometry  : Geometry, Spline, Curve, Mesh, Point, Instance, Volume
            Special   : Collection, Object, Material, Texture, Image
        The methods and properties of the sockets are implemented by creating nodes:
            circle = Mesh.Circle(radius=2.) --> creates the node GeometryNodeMeshCircle
            
A node accepts data sockets as inputs and return data sockets as ouputs
In addition, it can take parameters

====================================================================================================
Use

In a Blender project, create a Geometry nodes modifier and run the following script

from generator.generator import gen_geonodes

gen_geonodes(fpath)

where fpath is the folder into which generating the files


====================================================================================================
geonodes is made of following structure

----------------------------------------------------------------------------------------------------
----- geonodes.core

----- geonodes.core.node

Tree        : Blender NodeTree wrapper
DataSocket  : Root class for socket wrappers
Node        : Root class for blender geometry nodes wrappers

Some specific nodes are implemented in this module
They are used by Tree:
    
NodeGroup   : Root for GroupInput and GroupOutput

GroupInput  : Wrapper for node NodeGroupInput
              property: tree.group_input
              
GroupOutput : Wrapper for node NodeGroupOutput
              property: tree.group_output
              
Viewer      : Wrapper for node GeometryNodeViewer
              One viewer per tree. Data sockets can use the method to_viewer()
              
Frame       : Wrapper for node NodeFrame
              Tree implemenents new_layout() and close_layout() using Frame

SceneTime   : Wrapper for GeometryNodeInputSceneTime        


----- geonodes.core.datasockets

Implements the base class for DataSockets
All the classes are base on geonode.node.DataSocket

For geometry data, only the class Geometry is implemented in this module
The final classes will be created in geonodes.sockets with the following inheritance

Geometry
    - Spline
        - Curve
    - Mesh
        - Points
        - Instance
        - Volume
        
----- geonodes.core.colors

Some colors constants

----- geonodes.core.arrange

arrange function locates the nodes to make the whole tree somehow readable
It works independantly of the geonodes structure and just take the name
of the NodeTree as an argument.

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.nodes

All he nodes generated by the generator

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.sockets

One file per data socket class plus functions.py which contains the global functions

----------------------------------------------------------------------------------------------------
----- geonodes.__init__.py

The pack initi file contains

====================================================================================================

Generation principle

The generation module is designed to ease the updates with the new versions of geometry nodes

Step 1
------
    try to create all the possible nodes by listing all the types in bpy.types:
    
    for type_name in dir(bpy.types):
        try:
            node = nodes.new(type_name)
        except:
            continue
        
        # We have a valid type
        
    The legacy nodes are excluded from the scane
    
Step 2
------
    Each node is analyzed by:
        - Identifying the parameters (non standard attributes)
            Three types of parameters are possible:
                - Non settable parameters, for instance the color selector of an input color node
                - Enum parameters: str param with a list of valid values
                - Non enum settable parameters, the resolution of a circle for instance
            The settable parameters will be part of the node creation argument
        
        - Identifying if the node has "shared sockets"
            Shared sockets are sockets of different types but sharing the same name.
            Only one socket is enabled at a time, depending upon a "driving parameter"
            Example: node FunctionNodeCompare:
                    - Driving parameter : data_type in ('FLOAT', 'INT', 'VECTOR', 'STRING', 'RGBA')
                    - Input sockets     : ['a', 'b']
                    a and b are names shared by sockets of type Float, Integer, Vector, String and Color
                    
        - Renaming sockets homonyms when exist
            For instance node ShaderNodeMath has three input sockets named Value. They are renamed
            value0, value1 and value2
                    
Step 3
------
    file nodes.py generation in folder geonodes.nodes
    
    The __init__ method of the node class is the concatenation of the input sockets and the settable parameters
    
    for instance, the __init__ method of ShaderNodeMath is:
        
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD'):
            
            The node has 3 sockets and one parameter named operation.
            The default value 'ADD' is the one of the parameter at creation time.
            When a socket has the value None, it is left unplugged.
            A socket can be either a value or data socket class. If it is a value, it
            must be an acceptable default value for the input socket.
            
    An additional argument label is used to allow the user to change the node label:
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD', label=None):
            
Step 4
------
    Generation of the data sockets classes.
    
    A data socket basically wraps an output node socket.
    The methods of a data class consist in creating a node and to plug the socket to one
    input socket of this node.
    
    Example:
        Let use x as a Float which is the output socket of a node.
        We can write:
            
            y = x ** 3
            
        This will create the node ShaderNodeMath with the following parameters:
            
            node = Math(value0=self, value1=3, operation='POWER')
            return node.value
        
    Implementation types
    ---------------------
    
    Depending on their behaviors, the nodes can be implented in the following ways:
        
        Constructor
        -----------
            For nodes which don't transform a socket but create new data
            
            Example: GeometryNodeMeshCircle is implemented as a Mesh constructor
            
            @classmethod
            def Circle(cls, vertices=None, radius=None, fill_type='NONE'):
                return cls(nodes.MeshCircle(vertices=vertices, radius=radius, fill_type=fill_type).mesh)
            
        Property
        --------
            For node which return info on data sockets. The properties are kept in local attributes:
                
                self.prop_ = ... node creation
                return self.prop_
            
            Example: GeometryNodeBoundBox returns 3 infos on the geometry : bounding_box, min and max


"""

import bpy
import mathutils
from pprint import pprint, pformat

import logging
logger = logging.getLogger('geonodes')
logger.setLevel(logging.INFO)

from generator import gen_sockets as gsock
from generator import gen_doc as gd


import importlib
importlib.reload(gsock)

# ====================================================================================================
# Some nodes need to reorder the input sockets for more natural use
# Example : the input sockets node ShaderNodeMixRGB are order fac, color1, color2
#           by reordering color1, color2, fac allows to call color.mix(color_argument)
#           rather than color.mix(color2=color_argument)

INPUT_SOCKETS_ORDER = {
    'ShaderNodeMixRGB' : {'Fac': 2, 'Color1': 0, 'Color2': 1},
}

# ====================================================================================================
# Utility

def indent_set(depth=0):
    _indent_ = "    "
    _0_ = "\n" + _indent_ * max(0, 0 + depth)
    _1_ = "\n" + _indent_ * max(0, 1 + depth)
    _2_ = "\n" + _indent_ * max(0, 2 + depth)
    _3_ = "\n" + _indent_ * max(0, 3 + depth)
    _4_ = "\n" + _indent_ * max(0, 4 + depth)
    
    return _indent_, _0_, _1_, _2_, _3_, _4_

_indent_, _0_, _1_, _2_, _3_, _4_ = indent_set(0)


# ====================================================================================================
# Call argument
#
# Argument types:
#
# - SOCKET: The name of an input socket (wsocket must be not None).
#           If the socket is multi input, it must be the first argument:
#               - header: *name
#               - call  : *name
#           If the socket is not multi input
#               - header: name=None
#               - call  : name=name
#
# - PARAM : it is the name of a param (param can be None). It can be fixed or not
#           If fixed:
#               - header: ""
#               - call  : name=name
#           If not fixed
#               - header: name='VALUE'
#               - call  : name=name
#
# - CLS   : it is the cls argument
#         : - header : cls
#         : - call   : ""
#
# - OTHER : Not a socket nor a param
#         : - header : ""
#         : - call   : ""


class Argument:
    def __init__(self, arg_type, name, is_self=False):

        self.arg_type = arg_type
        self.name     = name
        self.is_self  = is_self
    
    def __init__OLD(self, name, value, quote_str_value=True, is_self=False, wsocket=None, param=None, is_fixed=False):
        
        self.name  = name
        
        if isinstance(value, str) and quote_str_value:
            self.value = f"'{value}'"
        else:
            self.value = value
        
        self.is_self  = is_self
        self.wsocket  = wsocket
        self.param    = param
        self.is_fixed = is_fixed
        
    @classmethod
    def Socket(cls, name, wsocket, is_self=False):
        arg         = cls('SOCKET', name, is_self=is_self)
        arg.wsocket = wsocket
        arg.is_self = is_self
        return arg
        
    @classmethod
    def Param(cls, name, value, quote_str_value=True, param=None, is_fixed=False):
        arg = cls('PARAM', name)
        if isinstance(value, str) and quote_str_value:
            arg.value = f"'{value}'"
        else:
            arg.value = value

        arg.param    = param
        arg.is_fixed = is_fixed
        return arg
        
    @classmethod
    def Cls(cls):
        return cls('CLS', "cls")
    
    @classmethod
    def Other(cls, header_str="", call_str="", **kwargs):
        arg = cls('OTHER', None)
        arg.header_str = header_str
        arg.call_str   = call_str
        for k, v in kwargs:
            setattr(arg, k, v)
        return arg
        
    @property
    def is_socket(self):
        return self.arg_type == 'SOCKET'
    
    @property
    def is_multi(self):
        if self.is_socket and not self.is_shared:
            return self.wsocket.is_multi_input
        else:
            return False
    
    @property
    def is_param(self):
        return self.arg_type == 'PARAM'

    @property
    def is_cls(self):
        return self.arg_type == 'CLS'
    
    @property
    def is_shared(self):
        return isinstance(self.wsocket, list)
    
    @property
    def scall_demo(self):
        
        if self.arg_type == 'CLS':
            return ""
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                return f"{self.name}_1, {self.name}_2, {self.name}_3"
            elif self.is_self:
                return ""
            else:
                return self.name
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return ""
            else:
                return self.name
            
        elif self.arg_type == 'OTHER':
            return self.header_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")
        
    
    @property
    def sheader(self):
        
        if self.arg_type == 'CLS':
            return "cls"
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name}"
                else:
                    return f"*{self.name}"
            else:
                if self.is_self:
                    return "self"
                else:
                    return f"{self.name}=None"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return ""
            else:
                return f"{self.name}={self.value}"
            
        elif self.arg_type == 'OTHER':
            return self.header_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

    @property
    def scall(self):

        if self.arg_type == 'CLS':
            return ""
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name}"
                else:
                    return f"*{self.name}"
            else:
                if self.is_self:
                    return f"{self.name}=self"
                else:
                    return f"{self.name}={self.name}"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return f"{self.name}={self.value}"
            else:
                return f"{self.name}={self.name}"
            
        elif self.arg_type == 'OTHER':
            return self.call_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

        
    @property
    def scomment(self):
        
        if self.arg_type == 'CLS':
            return ""
        
        if self.arg_type == 'OTHER':
            if self.header_str == "":
                return ""
            else:
                return self.header_str.replace('=', ':')
        
        s = f"{self.name} : "
        if self.is_socket:
            if self.is_multi:
                s += "*"
            s += self.wsocket.class_name
            if self.is_self:
                s += " (self)"
        else:
            if self.param is None:
                s += f"{self.value} ({type(self.value).__name__})"
            else:
                s += str(self.value)
                if self.param.is_enum and not self.is_fixed:
                    s += f" in {self.param.short_values}"
                    
        return s
    
    @property
    def splug(self):
        if not self.is_socket or self.is_shared:
            return None
        
        s = f"self.plug({self.wsocket.index}, "
        if self.is_self:
            s += "self"
            if self.is_multi:
                s += f" *{self.wsocket.uname}"
            return s + ")"
        else:
            if self.is_multi:
                s += "*"
            return s + f"{self.wsocket.uname})"
        
# ---------------------------------------------------------------------------
# A list of Arguments

class Arguments(list):
    
    def add(self, arg):
        if arg.is_self or arg.is_cls:
            self.insert(0, arg)
            
        elif arg.is_multi:
            if len(self) == 0:
                self.append(arg)
            elif self[0].is_self:
                self.insert(1, arg)
            else:
                self.insert(0, arg)
                
        else:
            self.append(arg)
    
    def add_attribute_args(self, domain='POINT', data_type='FLOAT', fixed_domain=False):
        self.append(Argument('owner_socket', 'self',     is_fixed=True, quote_str_value = False))
        self.append(Argument('domain',        domain,    is_fixed=fixed_domain))
        self.append(Argument('data_type',     data_type, is_fixed=True))
        
        
    @property
    def scall_demo(self):
        s = ""
        for arg in self:
            sh = arg.scall_demo
            if sh != "":
                s += f", {sh}"
        if s != "":
            return s[2:]
        else:
            return s
        
    @property
    def sheader(self):
        s = ""
        for arg in self:
            sh = arg.sheader
            if sh != "":
                s += f", {sh}"
        if s != "":
            return s[2:]
        else:
            return s
        
    @property
    def scall(self):
        s = ""
        for arg in self:
            if arg.is_cls:
                continue
            
            if arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"
            
        for arg in self:
            if not arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"

        if s != "":
            return s[2:]
        else:
            return s

    # ---------------------------------------------------------------------------
    # Check the order of the sockets arguments
    
    def check_order(self, bl_idname):

        order = INPUT_SOCKETS_ORDER.get(bl_idname)
        if order is None:
            return
        reorder = [None] * len(order)
        for arg in self:
            if not arg.is_socket:
                continue
            
            name = arg.wsocket.bsocket.name
            if name in order:
                reorder[order[name]] = arg
        
        for arg in reorder:
            if arg is not None:
                self.remove(arg)
            
        for arg in reversed(reorder):
            if arg is not None:
                self.insert(0, arg)

    # ---------------------------------------------------------------------------
    # Generate the comments in a node call
    
    def comment_section(self, section):
        
        for arg in self:
            
            sect = None
            if arg.arg_type == 'OTHER':
                if arg.header_str == "":
                    s = arg.call_str
                    sect = section.get_subsection("Fixed parameters")
                else:
                    s = arg.header_str
                    sect = section.get_subsection("Parameters arguments")
                if s == "":
                    continue
                scomment = s.replace("=", ":")

            else:
                scomment = arg.scomment
                if scomment == "":
                    continue
            
            if arg.is_socket:
                sect = section.get_subsection("Sockets arguments")

            elif arg.is_param:
                if arg.is_fixed:
                    sect = section.get_subsection("Fixed parameters")
                else:
                    sect = section.get_subsection("Parameters arguments")
                    
            lst = sect.get_lists(align_char=':')[0]
            lst.add_item(gd.Text(scomment))
            
        
    def gen_comment_OLD(self, _i_):
        
        ok_sockets = True
        ok_params  = True
        ok_fixed   = False
        for arg in self:
            if arg.is_socket:
                if ok_sockets:
                    yield _0_
                    yield _i_ + "Sockets arguments"
                    yield _i_ + "-----------------"
                    ok_sockets = False
                yield _i_ + _indent_ + arg.scomment

            if arg.is_param:
                if arg.is_fixed:
                    ok_fixed = True
                else:
                    if ok_params:
                        yield _0_
                        yield _i_ + "Parameters arguments"
                        yield _i_ + "--------------------"
                        ok_params = False
                    yield _i_ + _indent_ + arg.scomment
                
        if ok_fixed:
            yield _0_
            yield _i_ + "Fixed parameters"
            yield _i_ + "----------------"

            for arg in self:
                if arg.is_param and arg.is_fixed:
                    yield _i_ + _indent_ + arg.scomment

# ====================================================================================================
# Socket wrapper

class WSocket:
    
    SOCKET_CLASSES = {
        'NodeSocketBool'        : ('Boolean',    '',             'BOOLEAN'), 

        'NodeSocketInt'         : ('Integer',    '',             'INT'), 
        'NodeSocketIntUnsigned' : ('Integer',    'Unsigned',     'INT'), 

        'NodeSocketFloat'       : ('Float',      '',             'FLOAT'), 
        'NodeSocketFloatFactor' : ('Float',      'Factor',       'FLOAT'),
        'NodeSocketFloatAngle'  : ('Float',      'Angle',        'FLOAT'), 
        'NodeSocketFloatDistance': ('Float',     'Distance',     'FLOAT'), 

        'NodeSocketVector'      : ('Vector',     '',             'FLOAT_VECTOR'), 
        'NodeSocketVectorEuler' : ('Vector',     'Rotation',     'FLOAT_VECTOR'),
        'NodeSocketVectorXYZ'   : ('Vector',     'xyz',          'FLOAT_VECTOR'), 
        'NodeSocketVectorTranslation' : ('Vector', 'Translation','FLOAT_VECTOR'), 

        'NodeSocketColor'       : ('Color',      '',             'FLOAT_COLOR'), 
        'NodeSocketString'      : ('String',     '',             'FLOAT_COLOR'), 

        'NodeSocketGeometry'    : ('Geometry',   '',              None), 

        'NodeSocketCollection'  : ('Collection', '',              None), 
        'NodeSocketImage'       : ('Image',      '',              None), 
        'NodeSocketMaterial'    : ('Material',   '',              None), 
        'NodeSocketObject'      : ('Object',     '',              None), 
        'NodeSocketTexture'     : ('Texture',    '',              None), 
        'NodeSocketVirtual'     : ('Virtual',    '',              None),
        }
        
    DATA_TYPES = {
        'INT'         : 'Integer',
        'RGBA'        : 'Color',
        'FLOAT_VECTOR': 'Vector',
        'FLOAT_COLOR' : 'Color',
    }
    
    DOMAIN_DATA_TYPES = {
        'Float'     : 'FLOAT',
        'Integer'   : 'INT',
        'Vector'    : 'FLOAT_VECTOR',
        'Color'     : 'FLOAT_COLOR',
        'Boolean'   : 'BOOLEAN'
    }

    def __init__(self, bsocket, index):
        self.bsocket    = bsocket
        self.index      = index
        self.uname      = self.name
        self.class_name = WSocket.SOCKET_CLASSES[self.bsocket.bl_idname][0]
        self.domain_data_type = WSocket.DOMAIN_DATA_TYPES.get(self.class_name)
        if self.class_name == 'Geometry':
            if self.name.lower() in ['mesh', 'points', 'instances', 'volume', 'spline', 'curve']:
                self.class_name = self.name.capitalize()
                
    def __repr__(self):
        return f"<{self.uname} ({self.class_name})>"
    
    @staticmethod
    def domain_data_type(bl_idname):
        return WSocket.SOCKET_CLASSES[bl_idname][2]
    
    @property
    def bl_idname(self):
        return self.bsocket.bl_idname
        
    @property
    def enabled(self):
        return self.bsocket.enabled
    
    @property
    def name(self):
        s = self.bsocket.name.lower().replace(' ', '_')
        if s == 'id':
            return 'ID'
        else:
            return s
    
    @property
    def is_multi_input(self):
        return self.bsocket.is_multi_input
    
    @property
    def is_output(self):
        return self.bsocket.is_output
    
# ---------------------------------------------------------------------------
# A list of WSockets

class WSockets(list):
    
    def __init__(self, bsockets):
        super().__init__()
        self.bsockets = bsockets
        for index, bsocket in enumerate(self.bsockets):
            if bsocket.bl_idname != 'NodeSocketVirtual':
                self.append(WSocket(bsocket, index))
            
        # ---------------------------------------------------------------------------
        # Sockets can have the same name. Two cases:
        # 1. HOMNYMS: They are of the same class
        #    Only for input sockets. It correspond to parameters of same types,
        #    for instance for an operation
        # 2. SHARED: They are not of the same class
        #    Only one of them can be enabled
        
        names = {}
        for wsock in self:
            if wsock.name in names:
                names[wsock.name].append(wsock)
            else:
                names[wsock.name] = [wsock]
                
        # ----- unames
        # - key   : the unique name shared between several sockets
        # - value : the list of wsockets it is shared among
                
        self.unames = {}
        for name, wsocks in names.items():
            if len(wsocks) == 1:
                self.unames[name] = wsocks[0]
            else:
                class_name = wsocks[0].class_name
                distinction = 'HOMONYMS'
                for wsock in wsocks:
                    if wsock.class_name != class_name:
                        self.unames[wsock.name] = wsocks
                        distinction = 'SHARED'
                        break
                    
                if distinction == 'HOMONYMS':
                    if wsocks[0].is_output:
                        raise RuntimeError("Big mistake !!!")
                    for i, wsock in enumerate(wsocks):
                        wsock.uname = f"{name}{i}"
                        self.unames[wsock.uname] = wsock
                        
        # ----- unames indices
        # - key     : the unique name
        # - value   : a dictionay giving the socket index from the driving
        #             parameter value
        # Initialized by the owner node by making vary the driving parameter
        # and by calling the method update_unames_indices
        #
        # Example:
        # unames_indices = {'from_value': {'FLOAT': 0, 'VECTOR': 2}, 'to_value': {'FLOAT': 1, 'VECTOR' : 3}}

        self.unames_indices = {}
        for uname in self.unames:
            self.unames_indices[uname] = {}
            
    # ----------------------------------------------------------------------------------------------------
    # The sockets which are shared according a driving parameter                 
                        
    @property
    def shared_sockets(self):
        sel = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                sel[uname] = wsocks
        return sel
    
    # ----------------------------------------------------------------------------------------------------
    # The node makes vary the driving parameter. At each change, it calls the following
    # method to update the unames_indices dictionary
        
    def update_unames_indices(self, param_value):
        for uname, wsocks in self.shared_sockets.items():
            for wsock in wsocks:
                if wsock.enabled:
                    if self.unames_indices[uname].get(param_value) is not None:
                        raise RuntimeError("Unconsistant, really !")
                    self.unames_indices[uname][param_value] = wsock.index
    

    # ----------------------------------------------------------------------------------------------------
    # Get the currently enabled sockets
    
    def enabled_sockets(self):
        wsockets = []
        for wsock in self:
            if wsock.enabled:
                wsockets.append(wsock)
        return wsockets
    
    # ====================================================================================================
    # Output sockets indices
    # Used to build the output_sockets property of the generated class
    
    def get_socket_indices(self, fixed):
        inds = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                index = self.unames[uname][fixed[self.driving_param]]
            else:
                index = wsocks.index
            inds[uname] = index
        return inds
    
# ====================================================================================================
# A parameter wrapper

class Parameter:
    def __init__(self, wnode, name):
        self.wnode   = wnode
        self.name    = name
        self.uname   = name

        self.is_enum = False
        self.default = self.value
        self.param_type = type(self.default).__name__ 
        
        if isinstance(self.default, bpy.types.bpy_struct):
            self.default = None
        elif isinstance(self.default, mathutils.Vector):
            self.default = list(self.default)
        if isinstance(self.default, str):
            try:
                setattr(self.wnode.bnode, self.name, 'ERROR')
                #self.value = 'ERROR'
            except TypeError as e:
                msg = str(e)
                i = msg.find('enum "ERROR" not found in')
                self.is_enum = i > 0
                if self.is_enum:
                    self.values = eval(msg[i+26:])
                    
    @property
    def sdefault(self):
        if isinstance(self.default, str):
            return f"'{self.default}'"
        else:
            return self.default
        
    @property
    def value(self):
        return getattr(self.wnode.bnode, self.name)
    
    @value.setter
    def value(self, v):
        try:
            setattr(self.wnode.bnode, self.name, v)
        except:
            print(f"CAUTION: error when setting parameter {self.name} with value '{v}'")
        
    def reset(self):
        if self.default is not None:
            self.value = self.default
            
    @property
    def short_values(self):
        s = ""
        ok_pass = True
        for i, value in enumerate(self.values):
            if (len(s) < 30) or (i >= len(self.values)-3):
                s += f", {value}"
            else:
                if ok_pass:
                    s += ',... '
                    ok_pass = False
        return f"[{s[2:]}]"
        
            
# ====================================================================================================
# A node wrapper

class WNode:
    
    WNODES = {}
    
    STD_ATTRS = [
       '__doc__', '__module__', '__slots__', 'bl_description', 'bl_height_default', 'bl_height_max',
       'bl_height_min', 'bl_icon', 'bl_idname', 'bl_label', 'bl_rna', 'bl_static_type',
       'bl_width_default', 'bl_width_max', 'bl_width_min', 'color', 'dimensions', 'draw_buttons',
       'draw_buttons_ext', 'height', 'hide', 'input_template', 'inputs', 'internal_links',
       'is_registered_node_type', 'label', 'location', 'mute', 'name', 'output_template', 'outputs',
       'parent', 'poll', 'poll_instance', 'rna_type', 'select', 'show_options', 'show_preview',
       'show_texture', 'socket_value_update', 'type', 'update', 'use_clamp', 'use_custom_color',
       'width', 'width_hidden']
    
    def __init__(self, bnode):
        
        WNode.WNODES[bnode.bl_idname] = self
        
        self.bnode   = bnode
        self.inputs  = WSockets(self.bnode.inputs)
        self.outputs = WSockets(self.bnode.outputs)
        
        self.parameters = {}
        for param_name in dir(self.bnode):
            if not param_name in WNode.STD_ATTRS:
                param = Parameter(self, param_name)
                if param.default is None:
                    continue
                    
                self.parameters[param_name] = param
                if param_name in self.outputs.unames:
                    self.parameters[param_name].uname = param_name + '_'
                    
        # ----- shared sockets : a unique name is shared between several sockets
                    
        self.has_shared_sockets = bool(self.inputs.shared_sockets) or bool(self.outputs.shared_sockets)
        
        if self.has_shared_sockets:
            self.driving_param = 'input_type' if hasattr(self.bnode, 'input_type') else 'data_type'
            
            param = self.parameters[self.driving_param]
            for value in param.values:
                param.value = value
                self.inputs.update_unames_indices(value)
                self.outputs.update_unames_indices(value)
                
        # ----- Data sockets calling this node
        
        self.data_sockets = {}
                

    def __str__(self):
        return f"[{self.node_name}]"
        
    @property
    def bl_idname(self):
        return self.bnode.bl_idname
    
    @property
    def node_name(self):
        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            if word.lower() == 'id':
                s += 'ID'
            else:
                s += word.capitalize()
        return s
        #return "Node" + s
    
    @property
    def function_name(self):
        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            w = word.lower()
            if w == 'id':
                w = 'ID'
            if w == '_':
                s += '_'
            else:
                if s != "":
                    s += '_'
                s += w
        return s
    
    # ---------------------------------------------------------------------------
    # Set parameters

    def reset_params(self):
        for param in self.parameters.values():
            param.reset()

    def set_params(self, param_values={}):
        for name, param in self.parameters.items():
            if name in param_values:
                param.value = param_values[name]
            else:
                param.reset()
                
    # ----------------------------------------------------------------------------------------------------
    # Non driving parameters
    
    def non_driving_params(self):
        params = {}
        for name, param in self.parameters.items():
            if name == self.driving_param:
                continue
            params[name] = Parameter(self, name)
        return params
    
    # ----------------------------------------------------------------------------------------------------
    # Node arguments
    
    def get_node_arguments(self):

        args = Arguments()
        for uname, wsock in self.inputs.unames.items():
            args.add(Argument.Socket(uname, wsocket=wsock))
            
        for name, param in self.parameters.items():
            args.append(Argument.Param(name, param.default, param=param))
            
        args.check_order(self.bl_idname)
            
        return args
    
    # ====================================================================================================
    # Enabled sockets with the fixed parameters
    # makes the free parameters vary to check which sockets to use
    
    def sockets_unames(self, wsockets, fixed={}):
    
        self.set_params(fixed)
        
        ens = [wsock.enabled for wsock in wsockets]
        for name, param in self.parameters.items():
            if name in fixed:
                continue
            if not param.is_enum:
                continue
            
            # ----- Reload the enum values to explore the possibilities
            
            new_param = Parameter(self, name)
            for value in new_param.values:
                param.value = value
                for i, wsock in enumerate(wsockets):
                    if wsock.enabled:
                        ens[i] = True
            new_param.value = new_param.default
        
        # ----- Let's keep only the outputs which can be enabled
        
        self.set_params(fixed)

        fixed_shared = True
        if self.has_shared_sockets:
            fixed_shared = self.driving_param in fixed
                
        unames = {}
        for i, wsock in enumerate(wsockets):
            if ens[i] and (wsock.uname not in unames):
                if fixed_shared or wsock.uname not in wsockets.shared_sockets:
                    unames[wsock.uname] = wsock.class_name
                else:
                    unames[wsock.uname] = f"{self.driving_param} dependant"
                    
        return unames

    # ----------------------------------------------------------------------------------------------------
    # Argument sockets

    def input_unames(self, fixed={}):
        return self.sockets_unames(self.inputs, fixed=fixed)
    
    # ----------------------------------------------------------------------------------------------------
    # Returned sockets
    
    def output_unames(self, fixed={}):
        return self.sockets_unames(self.outputs, fixed=fixed)
    
    # ====================================================================================================
    # Formatting utility
    
    @staticmethod
    def format_list(values, width=100, first_width=None):
        
        if not values:
            return "[]"
        
        is_str = isinstance(values[0], str)
        if first_width is None:
            first_width = width
        w = first_width
        s = "["
        sep = ""
        for i, value in enumerate(values):
            if is_str:
                s += f"{sep} '{value}'"
            else:
                s += "{sep} {str(value)}"
            if len(s) >= w:
                if i == len(values)-1:
                    yield s + "]"
                else:
                    yield s + ","
                s   = ""
                sep = ""
                w   = width
                
        if s != "":
            yield s + "]"
            
            
    # ====================================================================================================
    # Build the documentation
    
    def build_doc(self, wrap_parameters=True):
        
        args = self.get_node_arguments()
        
        # ----- Title and description
                
        self.doc = gd.Section(f"Class {self.node_name}", level=0)
        self.doc.append(
            gd.Description("Geometry node name:", gd.Italic(f"'{self.bnode.name}'"), gd.br, "Blender type: ", gd.Bold(self.bnode.bl_idname))
            )
        
        self.doc.append(gd.Doc(gd.Link("Index", "/docs/index.md")))
        
        
        # ----- Initialization
        
        section = self.doc.get_subsection("Initialization")
        
        python  = "from geonodes import nodes\n"
        python += f"node = nodes.{self.node_name}("
        s = args.sheader
        python += s
        if s != "":
            python += ", "
        python += "label=None)"
        
        section.append(gd.Python(python))
        
        section = section.get_subsection("Arguments")
    
        if self.inputs:
            sect = section.get_subsection("Input sockets")
            lst = gd.List(align_char=':')
            sect.append(lst)
            for uname, wsock in self.inputs.unames.items():
                txt = gd.Text(gd.Bold(uname), ":")
                if isinstance(wsock, list):
                    txt.add(gd.Bold(self.driving_param), "dependant")
                else:
                    if wsock.is_multi_input:
                        txt.add("*")
                    txt.add(gd.Italic(wsock.class_name))
                lst.add_item(txt)
        
        if self.parameters:
            sect = section.get_subsection("Parameters")
            lst = gd.List(align_char=':')
            sect.append(lst)
            
            for name, param in self.parameters.items():
                txt = gd.Text(gd.Bold(name), ":")
                stype = param.param_type
                if stype == 'str':
                    txt.add(gd.Italic(f"'{param.default}'"))
                else:
                    txt.add(gd.Italic(str(param.default)))
                
                if param.is_enum:
                    txt.add(f"in {param.values}")
                else:
                    txt.add(stype)
                lst.add_item(txt)
                    
        sect = section.get_subsection("Node label")
        lst = gd.List(align_char=':')
        sect.append(lst)
        lst.add_item(gd.Text(gd.Bold("label"), ": Geometry node label"))
        
        # ----- Data type dependant sockets
                    
        if self.has_shared_sockets:
            
            section = self.doc.get_subsection("Data type dependant sockets")
            lst = gd.List(align_char=':')
            section.append(lst)
            lst.add_item(gd.Text("Driving parameter :", gd.Bold(self.driving_param), f"in {self.parameters[self.driving_param].values}"))
            
            inds = self.inputs.shared_sockets
            if inds:
                #lst.add_item(gd.Text(f"Input sockets : {list(inds.keys())}"))
                lst.add_item(gd.Text("Input sockets :", *list(inds.keys())))
                
            inds = self.outputs.shared_sockets
            if inds:
                lst.add_item(gd.Text("Output sockets :", *list(inds.keys())))
                #lst.add_item(gd.Text(f"Output sockets : {list(inds.keys())}"))

        # ----- Output sockets
    
        if self.outputs:
            
            section = self.doc.get_subsection("Output sockets")
            lst = gd.List(align_char=':')
            section.append(lst)
            
            for uname, wsock in self.outputs.unames.items():
                txt= gd.Text(gd.Bold(uname), ":")
                if isinstance(wsock, list):
                    txt.add(gd.Bold(self.driving_param), "dependant")
                else:
                    txt.add(gd.Italic(wsock.class_name))
                    if wsock.is_multi_input:
                        txt.add("(multi input)")

                lst.add_item(txt)
                
        # ----- Data classes
        
        if self.data_sockets:
            
            section = self.doc.get_subsection("Data sockets")
            section.append(gd.Description("Data socket classes implementing this node"))
            lst = gd.List(align_char=':')
            section.append(lst)
            
            classes = list(self.data_sockets.keys())
            classes.sort()
            for class_name in classes:
                refs = list(self.data_sockets[class_name])
                refs.sort()
                for meth_name, family in refs:
                    lst.add_item(gd.Text(
                        gd.Link(class_name, f"../sockets/{class_name}.md"),
                        gd.Link(meth_name, f"../sockets/{class_name}.md#{gd.Section.title_tag(meth_name)}"),
                        f": {family}"))
        
        return self.doc
            
    
    # ====================================================================================================
    # Generate the node class
    
    def gen_node_class(self, wrap_parameters=True):
        
        args = self.get_node_arguments()
        
        # ---------------------------------------------------------------------------
        # Class header
        #
        # class NodeMath(Node):
        
        yield _0_ + f"class {self.node_name}(Node):\n"
    
        # ---------------------------------------------------------------------------
        # Class comment
        
        doc = self.build_doc()
        first = True
        for line in doc.gen_text(width=100):
            if first:
                yield _1_ + '"""' + line
                first = False
            else:
                yield _1_ + line
                
        yield _1_ + '"""' + "\n"
    
        # ---------------------------------------------------------------------------
        # Constructor __init__
        #
        # def __init__(self, input sockets, param sockets, label):
    
        yield _1_ + "def __init__(self"
        s = args.sheader
        if s != "":
            yield ", " + s
        yield ", label=None):\n"
    
        # ---------------------------------------------------------------------------
        # Call of super
        #
        # super().__init__(bl_idname, name, label)
        
        yield _2_ + f"super().__init__('{self.bl_idname}', name='{self.bnode.name}', label=label)"

        # ---------------------------------------------------------------------------
        # Parameters
        #
        # self.bnode.data_type = data_type
        
        yield_comment = True
        if False:
            yield _2_ + "self.parameters = ["
            sep = ""
            for name in self.parameters:
                yield f"{sep}'{name}'"
                sep = ", "
            yield "]"
        
        for name, param in self.parameters.items():
            if yield_comment:
                yield _2_ + "# Parameters\n"
                yield_comment = False
            
            yield _2_ + f"self.bnode.{param.name:15s} = {name}"
        
        if not yield_comment:
            yield "\n"
    
        # ---------------------------------------------------------------------------
        # Shared Input sockets
        # if the node has shared sockets, two loops:
        # - loop on the possible values of the driving parameter
        # - loop on the shared input sockets
        #
        # inputs.shared_sockets: {socket.uname: [wsockets...]}
        # inputs.unames_indices: {socket.uname: {param value: index}}
        #
        # if data_type == 'FLOAT':
        #     self.plug(0, value0)
        #     self.plug(2, value1)
        # elif data_type == 'VECTOR':
        #     self.plug(1, value0)
        #     self.plug(3, value1)
        
        yield_comment = True
        if self.has_shared_sockets:
            param = self.parameters[self.driving_param]
            sif = "if"
            for index, value in enumerate(param.values):
                yield_if = True
                for uname, valinds in self.inputs.unames_indices.items():
                    idx = valinds.get(value)
                    if idx is not None:
                        
                        if yield_comment:
                            yield _2_ + "# Input sockets\n"
                            yield_comment = False
                        
                        if yield_if:
                            yield _2_ + f"{sif} {self.driving_param} == '{value}':"
                            sif = "elif"
                            yield_if = False
                        yield _3_ + f"self.plug({idx}, {uname})"
            yield "\n"

        # ---------------------------------------------------------------------------
        # Other input sockets
        #
        # self.plug(4, factor)
        
        for arg in args:
            if not arg.is_socket or arg.is_shared:
                continue
            
            if yield_comment:
                yield _2_ + "# Input sockets\n"
                yield_comment = False
            
            yield _2_ + arg.splug

        if not yield_comment:
            yield "\n"
        
        # ---------------------------------------------------------------------------
        # Shared outputs sockets
        #
        # See shared input sockets
        #
        # if data_type == 'FLOAT':
        #     self.value = self.Float(self.bnode.outputs[0])
        # elif data_type == 'VECTOR':
        #     self.value = self.Vector(self.bnode.outputs[1])
        
        yield_comment = True
        if self.has_shared_sockets:
            param = self.parameters[self.driving_param]
            sif = "if"
            for index, value in enumerate(param.values):
                yield_if = True
                for uname, valinds in self.outputs.unames_indices.items():
                    idx = valinds.get(value)
                    if idx is not None:
                        
                        if yield_comment:
                            yield _2_ + "# Output sockets\n"
                            yield_comment = False
                        
                        if yield_if:
                            yield _2_ + f"{sif} {self.driving_param} == '{value}':"
                            sif = "elif"
                            yield_if = False
                        yield _3_ + f"self.{uname:15s} = self.{self.outputs[idx].class_name}(self.bnode.outputs[{idx}])"

            yield "\n"
        
        # ---------------------------------------------------------------------------
        # Other output sockets
        #
        # self.fac = self.Float(self.bnode.outputs[2])
        
        socks = []
        for wsocket in self.outputs:
            
            if not wsocket.uname in socks:
                socks.append(wsocket.uname)
                
            if wsocket.uname in self.outputs.shared_sockets:
                continue
            
            if yield_comment:
                yield _2_ + "# Output sockets\n"
                yield_comment = False
            
            idx = wsocket.index
            yield _2_ + f"self.{wsocket.uname:15s} = self.{self.outputs[idx].class_name}(self.bnode.outputs[{idx}])"
            
        yield _2_ + "self.output_sockets  = {"
        sep = ""
        for sock in socks:
            yield f"{sep}'{sock}': self.{sock}"
            sep = ", "
        yield "}"

        yield "\n"
    
        # ---------------------------------------------------------------------------
        # Wrap the parameters
        
        if wrap_parameters:
            for name, param in self.parameters.items():
                yield _1_ +  "@property"
                yield _1_ + f"def {param.uname}(self):"
                yield _2_ + f"return self.bnode.{name}\n"
            
                yield _1_ + f"@{param.uname}.setter"
                yield _1_ + f"def {param.uname}(self, value):"
                yield _2_ + f"self.bnode.{name} = value\n"

        
# ====================================================================================================
# Generate the nodes module

# ----------------------------------------------------------------------------------------------------
# Create all the nodes

btree_nodes = bpy.data.node_groups["Geometry Nodes"].nodes
btree_nodes.clear()

class BNodes(dict):
    def __init__(self):
        super().__init__()
        for tp in dir(bpy.types):
            if tp.find('Legacy') < 0:
                try:
                    bnode = btree_nodes.new(tp)
                except:
                    continue
                self[tp] = bnode
                
# ----- Create the geometry nodes
                
BNODES = BNodes()

# ----- Create the wrapping nodes

for bnode in BNODES.values():
    WNode(bnode)

# ----- The generated nodes and sockets

generated_nodes   = []
generated_sockets = []


# ----------------------------------------------------------------------------------------------------
# Generate the classes
# 
# When a classes is created, it update the nodes it uses
                
def create_data_sockets(fpath):
    
    # ----- sockets files

    gsock.GEN_NODES = []
    class_gens = []
    
    nodes_md = {}
    
    # ---------------------------------------------------------------------------
    # Loop on the data sockets generators

    for i, dgen in enumerate(gsock.DATA_CLASSES):
        
        class_gen = dgen(WNode.WNODES)
        class_gens.append(class_gen)
        
        with open(fpath + f"sockets/{class_gen.class_name.lower()}.py", 'w') as f:

            for line in class_gen.gen_class():
                f.write(line)
                
            f.write("\n\n")
            
        class_gen.register_nodes()
        
        # ----------------------------------------------------------------------------------------------------
        # Markdown version of the class documentation
        
        fmd = fpath + f"docs/sockets/{class_gen.class_name}.md"
        with open(fmd, 'w') as fd:
            
            doc = class_gen.doc
            for line in doc.gen_md():
                fd.write(line + "\n")
        
            doc = class_gen.methods_documentation()
            for line in doc.gen_md():
                fd.write(line + "\n")

        # ----- For further indexing
                
        generated_sockets.append(class_gen.class_name)


# ----------------------------------------------------------------------------------------------------
# Creat all the nodes in 

def create_nodes(fpath):
    
    fname = fpath + "nodes/nodes.py"
    
    with open(fname, 'w') as f:
        f.write("from geonodes.core.node import Node\n")
        
        for bnode in BNODES.values():
            
            # ----------------------------------------------------------------------------------------------------
            # Load the node
            
            #wn = WNode(bnode)
            wn = WNode.WNODES[bnode.bl_idname]
            
            # ----- Some exclusion
            
            if wn.bl_idname in ['NodeReroute', 'NodeGroupInput', 'NodeGroupOutput', 'GeometryNodeViewer', 'NodeFrame']:
                logger.info(f"Ignore: {wn.bl_idname}")
                continue
            
            # ----- Write the node
            
            f.write(f"\n# {'-'*100}\n")
            f.write(f"# Node {wn.node_name} for {wn.bl_idname}\n")

            for line in wn.gen_node_class():
                f.write(line)
                
            # ----------------------------------------------------------------------------------------------------
            # Markdown version of the class documentation
            
            fmd = fpath + f"docs/nodes/{wn.node_name}.md"
            with open(fmd, 'w') as fd:
                doc = wn.doc
                for line in doc.gen_md():
                    fd.write(line + "\n")
                    
            # ----- For further indexing
                    
            generated_nodes.append(wn.node_name)

                    
                    
                    
# ====================================================================================================
# Generate the nodes module
                
def create_geonodes(fpath):

    # ---------------------------------------------------------------------------
    # data sockets classes
    
    create_data_sockets(fpath)

    # ---------------------------------------------------------------------------
    # nodes.py

    create_nodes(fpath)
    
    # ---------------------------------------------------------------------------
    #Index
    
    doc = gd.Section("Index", level=0)

    section = doc.get_subsection("Data sockets")
    
    lst = gd.List()
    for class_name in generated_sockets:
        lst.add_item(gd.Text(gd.Link(class_name, f"sockets/{class_name}.md")))

    section.append(lst)
        
    
    section = doc.get_subsection("Nodes")

    lst = gd.List()
    for node_name in generated_nodes:
        lst.add_item(gd.Text(gd.Link(node_name, f"nodes/{node_name}.md")))

    section.append(lst)
    
    
    fname = fpath + f"docs/index.md"
    with open(fname, 'w') as f:
        for line in doc.gen_md():
            f.write(line + "\n")
    

    
